[["index.html", "rxode2 user manual Chapter 1 Introduction", " rxode2 user manual Matthew Fidler, Melissa Hallow, Wenping Wang 2023-08-26 Chapter 1 Introduction Welcome to the rxode2 user guide; rxode2 is an R package for solving and simulating from ode-based models. These models are convert the rxode2 mini-language to C and create a compiled dll for fast solving. ODE solving using rxode2 has a few key parts: rxode2() which creates the C code for fast ODE solving based on a simple syntax (Chapter 6) related to Leibnitz notation. The event data, which can be: a NONMEM or deSolve compatible data frame (Chapter 7), or created with et() or EventTable() for easy simulation of events (Chapter 11) The data frame can be augmented by adding time varying or adding individual covariates (iCov= as needed) rxSolve() which solves the system of equations using initial conditions and parameters to make predictions With multiple subject data, this may be parallelized. With single subject the output data frame is adaptive Covariances and other metrics of uncertainty can be used to simulate while solving. While this is the user guide, there are other places that you can visit for help: rxode2 github pkgdown page rxode2 tutorial (accessible in tutorials in Rstudio 1.3+) rxode2 github discussions There is an Chinese rxode2 manual translated by Fu Yongchao which was translated based on the manual dated June 9, 2023. This book was assembled on Sat Aug 26 23:37:00 2023 with rxode2 version 2.0.13.9000 automatically by github actions. "],["author.html", "Chapter 2 Authors and Acknowledgments 2.1 Authors 2.2 Contributors 2.3 RxODE acknowledgments:", " Chapter 2 Authors and Acknowledgments 2.1 Authors Matthew L. Fidler (core team/developer/manual) Melissa Hallow (tutorial writer) Wenping Wang (core team/developer) 2.2 Contributors Zufar Mulyukov – Wrote initial version of rxShiny() with modifications from Matthew Fidler Alan Hindmarsh – Lsoda author Awad H. Al-Mohy – Al-Mohy matrix exponential author Ernst Hairer – dop853 author Gerhard Wanner – dop853 author Goro Fuji – Timsort author Hadley Wickham – Author of original findLhs in RxODE, also original author of .s3register (used with permission to anyone, both changed by Matthew Fidler) Jack Dongarra – LApack author Linda Petzold – LSODA Martin Maechler – expm author, used routines from there for inductive linearization Morwenn – Timsort author Nicholas J. Higham – Author of Al-mohy matrix exponential Roger B. Sidje – expokit matrix exponential author Simon Frost – thread safe C implementation of liblsoda Kevin Ushey – Original author of fast factor, modified by Matthew Filder Yu Feng – thread safe liblsoda Cleve Moler – LApack author David Cooley – Author of fast_factor which was modified and now is used RxODE to quickly create factors for IDs without sorting them like R does Drew Schmidt – Drew Schmidt author of edits for exponential matrix utility taken from R package expm Matt Dowle &amp; Arun Srinivasan – data.table authors on which the openMp framework is based upon 2.3 RxODE acknowledgments: Sherwin Sy – Weight based dosing example Justin Wilkins – Documentation updates, logo and testing Emma Schwager – R IJK distribution author J Coligne – dop853 fortran author Bill Denney – Documentation updates, manual and minor bug fixes Tim Waterhouse – Fixed one bug with mac working directories Richard Upton – Helped with solving the ADVAN linCmt() solutions Dirk Eddelbuettel – Made some fixes for the Rcpp changes require R strict headers Ross Ihaka – R author Robert Gentleman – R author R core team – R authors "],["related.html", "Chapter 3 Related R packages 3.1 ODE solving 3.2 PK Solved systems", " Chapter 3 Related R packages 3.1 ODE solving This is a brief comparison of pharmacometric ODE solving R packages to rxode2. There are several R packages for differential equations. The most popular is deSolve. However for pharmacometrics-specific ODE solving, there are only 2 packages other than rxode2 released on CRAN. Each uses compiled code to have faster ODE solving. mrgsolve, which uses C++ lsoda solver to solve ODE systems. The user is required to write hybrid R/C++ code to create a mrgsolve model which is translated to C++ for solving. In contrast, rxode2 has a R-like mini-language that is parsed into C code that solves the ODE system. Unlike rxode2, mrgsolve does not currently support symbolic manipulation of ODE systems, like automatic Jacobian calculation or forward sensitivity calculation (rxode2 currently supports this and this is the basis of nlmixr2’s FOCEi algorithm) dMod, which uses a unique syntax to create “reactions”. These reactions create the underlying ODEs and then created c code for a compiled deSolve model. In contrast rxode2 defines ODE systems at a lower level. rxode2’s parsing of the mini-language comes from C, whereas dMod’s parsing comes from R. Like rxode2, dMod supports symbolic manipulation of ODE systems and calculates forward sensitivities and adjoint sensitivities of systems. Unlike rxode2, dMod is not thread-safe since deSolve is not yet thread-safe. PKPDsim which defines models in an R-like syntax and converts the system to compiled code. Like mrgsolve, PKPDsim does not currently support symbolic manipulation of ODE systems. PKPDsim is not thread-safe. The open pharmacometrics open source community is fairly friendly, and the rxode2 maintainers has had positive interactions with all of the ODE-solving pharmacometric projects listed. 3.2 PK Solved systems rxode2 supports 1-3 compartment models with gradients (using stan math’s auto-differentiation). This currently uses the same equations as PKADVAN to allow time-varying covariates. rxode2 can mix ODEs and solved systems. 3.2.1 The following packages for solved PK systems are on CRAN mrgsolve currently has 1-2 compartment (poly-exponential models) models built-in. The solved systems and ODEs cannot currently be mixed. pmxTools currently have 1-3 compartment (super-positioning) models built-in. This is a R-only implementation. PKPDsim uses 1-3 “ADVAN” solutions using non-superpositioning. PKPDmodels has a one-compartment model with gradients. 3.2.2 Non-CRAN libraries: PKADVAN Provides 1-3 compartment models using non-superpositioning. This allows time-varying covariates. "],["install.html", "Chapter 4 Installation 4.1 Development version", " Chapter 4 Installation You can install the released version of rxode2 from CRAN with: install.packages(&quot;rxode2&quot;) The fastest way to install the development version of rxode2 is to use the r-universe service. This service compiles binaries of the development version for MacOS and for Windows so you don’t have to wait for package compilation: install.packages(c(&quot;dparser&quot;, &quot;rxode2ll&quot;, &quot;rxode2parse&quot;, &quot;rxode2random&quot;, &quot;rxode2et&quot;, &quot;rxode2&quot;), repos=c(nlmixr2=&quot;https://nlmixr2.r-universe.dev&quot;, CRAN=&quot;https://cloud.r-project.org&quot;)) If this doesn’t work you install the development version of rxode2 with devtools::install_github(&quot;nlmixr2/rxode2parse&quot;) devtools::install_github(&quot;nlmixr2/rxode2random&quot;) devtools::install_github(&quot;nlmixr2/rxode2et&quot;) devtools::install_github(&quot;nlmixr2/rxode2ll&quot;) devtools::install_github(&quot;nlmixr2/rxode2&quot;) To build models with rxode2, you need a working c compiler. To use parallel threaded solving in rxode2, this c compiler needs to support open-mp. You can check to see if R has working c compiler you can check with: ## install.packages(&quot;pkgbuild&quot;) pkgbuild::has_build_tools(debug = TRUE) If you do not have the toolchain, you can set it up as described by the platform information below: 4.0.1 Windows In windows you may simply use installr to install rtools: install.packages(&quot;installr&quot;) library(installr) install.rtools() Alternatively you can download and install rtools directly. 4.0.2 Mac OSX To get the most speed you need OpenMP enabled and compile rxode2 with that compiler. There are various options and the most up to date discussion about this is likely the data.table installation FAQ for MacOS. The last thing to keep in mind is that rxode2 uses the code very similar to the original lsoda which requires the gfortran compiler to be setup as well as the OpenMP compilers. If you are going to be using rxode2 and nlmixr together and have an older mac computer, I would suggest trying the following: library(symengine) If this crashes your R session then the binary does not work with your Mac machine. To be able to run nlmixr, you will need to compile this package manually. I will proceed assuming you have homebrew installed on your system. On your system terminal you will need to install the dependencies to compile symengine: brew install cmake gmp mpfr libmpc After installing the dependencies, you need to re-install symengine: install.packages(&quot;symengine&quot;, type=&quot;source&quot;) library(symengine) 4.0.3 Linux To install on linux make sure you install gcc (with openmp support) and gfortran using your distribution’s package manager. 4.0.4 R versions 4.0 and 4.1 For installation on R versions 4.0.x and 4.1.x, please see the instructions on how to install symengine in the nlmixr2 installation instructions: https://github.com/nlmixr2/nlmixr2#r-package-installation 4.1 Development version Since the development version of rxode2 uses StanHeaders, you will need to make sure your compiler is setup to support C++14, as described in the rstan setup page. For R 4.0, I do not believe this requires modifying the windows toolchain any longer (so it is much easier to setup). Once the C++ toolchain is setup appropriately, you can install the development version from GitHub with: # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;nlmixr2/rxode2parse&quot;) devtools::install_github(&quot;nlmixr2/rxode2random&quot;) devtools::install_github(&quot;nlmixr2/rxode2et&quot;) devtools::install_github(&quot;nlmixr2/rxode2ll&quot;) devtools::install_github(&quot;nlmixr2/rxode2&quot;) "],["gettingStarted.html", "Chapter 5 Getting Started 5.1 Specify Dosing and sampling in rxode2 5.2 Solving ODEs", " Chapter 5 Getting Started The model equations can be specified through a text string, a model file or an R expression. Both differential and algebraic equations are permitted. Differential equations are specified by d/dt(var_name) =. Each equation can be separated by a semicolon. To load rxode2 package and compile the model: library(rxode2) #&gt; rxode2 2.0.13.9000 using 8 threads (see ?getRxThreads) #&gt; no cache: create with `rxCreateCache()` mod1 &lt;- function() { ini({ # central KA=2.94E-01 CL=1.86E+01 V2=4.02E+01 # peripheral Q=1.05E+01 V3=2.97E+02 # effects Kin=1 Kout=1 EC50=200 }) model({ C2 &lt;- centr/V2 C3 &lt;- peri/V3 d/dt(depot) &lt;- -KA*depot d/dt(centr) &lt;- KA*depot - CL*C2 - Q*C2 + Q*C3 d/dt(peri) &lt;- Q*C2 - Q*C3 eff(0) &lt;- 1 d/dt(eff) &lt;- Kin - Kout*(1-C2/(EC50+C2))*eff }) } Model parameters may be specified in the ini({}) model block, initial conditions can be specified within the model with the cmt(0)= X, like in this model eff(0) &lt;- 1. You may also specify between subject variability initial conditions and residual error components just like nlmixr2. This allows a single interface for nlmixr2/rxode2 models. Also note, the classic rxode2 interface still works just like it did in the past (so don’t worry about breaking code at this time). In fact, you can get the classic rxode2 model $simulationModel in the ui object: mod1 &lt;- mod1() # create the ui object (can also use `rxode2(mod1)`) mod1 summary(mod1$simulationModel) 5.1 Specify Dosing and sampling in rxode2 rxode2 provides a simple and very flexible way to specify dosing and sampling through functions that generate an event table. First, an empty event table is generated through the “et()” function. This has an interface that is similar to NONMEM event tables: ev &lt;- et(amountUnits=&quot;mg&quot;, timeUnits=&quot;hours&quot;) %&gt;% et(amt=10000, addl=9,ii=12,cmt=&quot;depot&quot;) %&gt;% et(time=120, amt=2000, addl=4, ii=14, cmt=&quot;depot&quot;) %&gt;% et(0:240) # Add sampling You can see from the above code, you can dose to the compartment named in the rxode2 model. This slight deviation from NONMEM can reduce the need for compartment renumbering. These events can also be combined and expanded (to multi-subject events and complex regimens) with rbind, c, seq, and rep. For more information about creating complex dosing regimens using rxode2 see the rxode2 events section. 5.2 Solving ODEs The ODE can now be solved using rxSolve: x &lt;- mod1 %&gt;% rxSolve(ev) #&gt; using C compiler: ‘gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’ x #&gt; ── Solved rxode2 object ── #&gt; ── Parameters (x$params): ── #&gt; KA CL V2 Q V3 Kin Kout EC50 #&gt; 0.294 18.600 40.200 10.500 297.000 1.000 1.000 200.000 #&gt; ── Initial Conditions (x$inits): ── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ── #&gt; # A tibble: 241 × 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.23 #&gt; 5 4 44.5 5.98 3085. 1789. 1776. 1.23 #&gt; 6 5 36.5 7.18 2299. 1467. 2132. 1.21 #&gt; # ℹ 235 more rows This returns a modified data frame. You can see the compartment values in the plot below: library(ggplot2) plot(x,C2) + ylab(&quot;Central Concentration&quot;) Or, plot(x,eff) + ylab(&quot;Effect&quot;) Note that the labels are automatically labeled with the units from the initial event table. rxode2 extracts units to label the plot (if they are present). "],["syntax.html", "Chapter 6 rxode2 syntax 6.1 Example 6.2 Syntax 6.3 Logical Operators 6.4 Supported functions 6.5 Reserved keywords 6.6 Residual functions when using rxode2 functions 6.7 cmt() changing compartment numbers for states", " Chapter 6 rxode2 syntax This briefly describes the syntax used to define models that rxode2 will translate into R-callable compiled code. It also describes the communication of variables between R and the rxode2 modeling specification. 6.1 Example # An rxode2 model specification (this line is a comment). if(comed==0){ # concomitant medication (con-med)? F = 1.0; # full bioavailability w.o. con-med } else { F = 0.80; # 20% reduced bioavailability } C2 = centr/V2; # concentration in the central compartment C3 = peri/V3; # concentration in the peripheral compartment # ODE describing the PK and PD d/dt(depot) = -KA*depot; d/dt(centr) = F*KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; 6.2 Syntax This basic model specification consists of one or more statements optionally terminated by semi-colons ; and optional comments (comments are delimited by # and an end-of-line). A block of statements is a set of statements delimited by curly braces, { ... }. Statements can be either assignments, conditional if/else if/else, while loops (can be exited by break), special statements, or printing statements (for debugging/testing). Assignment statements can be: simple assignments, where the left hand is an identifier (i.e., variable) special time-derivative assignments, where the left hand specifies the change of the amount in the corresponding state variable (compartment) with respect to time e.g., d/dt(depot): special initial-condition assignments where the left hand specifies the compartment of the initial condition being specified, e.g. depot(0) = 0 special model event changes including bioavailability (f(depot)=1), lag time (alag(depot)=0), modeled rate (rate(depot)=2) and modeled duration (dur(depot)=2). An example of these model features and the event specification for the modeled infusions the rxode2 data specification is found in rxode2 events section. special change point syntax, or model times. These model times are specified by mtime(var)=time special Jacobian-derivative assignments, where the left hand specifies the change in the compartment ode with respect to a variable. For example, if d/dt(y) = dy, then a Jacobian for this compartment can be specified as df(y)/dy(dy) = 1. There may be some advantage to obtaining the solution or specifying the Jacobian for very stiff ODE systems. However, for the few stiff systems we tried with LSODA, this actually slightly slowed down the solving. Note that assignment can be done by =, &lt;- or ~. When assigning with the ~ operator, the simple assignments and time-derivative assignments will not be output. Note that with the rxode2 model functions assignment with ~ can also be overloaded with a residual distribution specification. Special statements can be: Compartment declaration statements, which can change the default dosing compartment and the assumed compartment number(s) as well as add extra compartment names at the end (useful for multiple-endpoint nlmixr models); These are specified by cmt(compartmentName) Parameter declaration statements, which can make sure the input parameters are in a certain order instead of ordering the parameters by the order they are parsed. This is useful for keeping the parameter order the same when using 2 different ODE models. These are specified by param(par1, par2,...) An example model is shown below: # simple assignment C2 &lt;- centr/V2 # time-derivative assignment d/dt(centr) &lt;- F*KA*depot - CL*C2 - Q*C2 + Q*C3; Expressions in assignment and if statements can be numeric or logical. Numeric expressions can include the following numeric operators +, -, *, /, ^ and those mathematical functions defined in the C or the R math libraries (e.g., fabs, exp, log, sin, abs). You may also access the R’s functions in the R math libraries, like lgammafn for the log gamma function. The rxode2 syntax is case-sensitive, i.e., ABC is different than abc, Abc, ABc, etc. 6.2.1 Identifiers Like R, Identifiers (variable names) may consist of one or more alphanumeric, underscore _ or period . characters, but the first character cannot be a digit or underscore _. Identifiers in a model specification can refer to: State variables in the dynamic system (e.g., compartments in a pharmacokinetics model). Implied input variable, t (time), tlast (last time point), and podo (oral dose, in the undocumented case of absorption transit models). Special constants like pi or R’s predefined constants. Model parameters (e.g., ka rate of absorption, CL clearance, etc.) Others, as created by assignments as part of the model specification; these are referred as LHS (left-hand side) variable. Currently, the rxode2 modeling language only recognizes system state variables and “parameters”, thus, any values that need to be passed from R to the ODE model (e.g., age) should be either passed in the params argument of the integrator function rxSolve() or be in the supplied event data-set. There are certain variable names that are in the rxode2 event tables. To avoid confusion, the following event table-related items cannot be assigned, or used as a state but can be accessed in the rxode2 code: cmt dvid addl ss rate id However the following variables are cannot be used in a model specification: evid ii Sometimes rxode2 generates variables that are fed back to rxode2. Similarly, nlmixr2 generates some variables that are used in nlmixr estimation and simulation. These variables start with the either the rx or nlmixr prefixes. To avoid any problems, it is suggested to not use these variables starting with either the rx or nlmixr prefixes. 6.3 Logical Operators Logical operators support the standard R operators ==, != &gt;= &lt;= &gt; and &lt;. Like R these can be in if() or while() statements, ifelse() expressions. Additionally they can be in a standard assignment. For instance, the following is valid: cov1 = covm*(sexf == &quot;female&quot;) + covm*(sexf != &quot;female&quot;) Notice that you can also use character expressions in comparisons. This convenience comes at a cost since character comparisons are slower than numeric expressions. Unlike R, as.numeric or as.integer for these logical statements is not only not needed, but will cause an syntax error if you try to use the function. 6.4 Supported functions All the supported functions in rxode2 can be seen with the rxSupportedFuns(). A brief description of the built-in functions are in the following table: Note that lag(cmt) = is equivalent to alag(cmt) = and not the same as = lag(wt) 6.5 Reserved keywords There are a few reserved keywords in a rxode2 model. They are in the following table: Note that rxFlag will always output 11 or calc_lhs since that is where the final variables are calculated, though you can tweak or test certain parts of rxode2 by using this flag. 6.6 Residual functions when using rxode2 functions In addition to ~ hiding output for certain types of output, it also is used to specify a residual output or endpoint when the input is an rxode2 model function (that includes the residual in the model({}) block). These specifications are of the form: var ~ add(add.sd) Indicating the variable var is the variable that represents the individual central tendencies of the model and it also represents the compartment specification in the data-set. You can also change the compartment name using the | syntax, that is: var ~ add(add.sd) | cmt In the above case var represents the central tendency and cmt represents the compartment or dvid specification. 6.6.1 Transformations For normal and related distributions, you can apply the transformation on both sides by using some keywords/functions to apply these transformations. Transformation rxode2/nlmixr2 code Box-Cox +coxBox(lambda) Yeo-Johnson +yeoJohnson(lambda) logit-normal +logitNorm(logit.sd, low, hi) probit-normal +probitNorm(probid.sd, low, hi) log-normal +lnorm(lnorm.sd) By default for the likelihood for all of these transformations is calculated on the untransformed scale. For bounded variables like logit-normal or probit-normal the low and high values are defaulted to 0 and 1 if missing. For models where you wish to have a proportional model on one of these transformation you can replace the standard deviation with NA To allow for more transformations, lnorm(), probitNorm() and logitNorm() can be combined the variance stabilizing yeoJohnson() transformation. 6.6.2 Normal and t-related distributions For the normal and t-related distributions, we wanted to keep the ability to use skewed distributions additive and proportional in the t/cauchy-space, so these distributions are specified differently in comparison to the other supported distributions within nlmixr2: Distribution How to Add Example Normal (log-likelihood) +dnorm() cp~add(add.sd)+dnorm() T-distribuion +dt(df) cp~add(add.sd)+dt(df) Cauchy (t with df=1) +dcauchy() cp~add(add.sd)+dcauchy() Note that with the normal and t-related distributions nlmixr2 will calculate cwres and npde under the normal assumption to help assess the goodness of the fit of the model. Also note that the +dnorm() is mostly for testing purposes and will slow down the estimation procedure in nlmixr2. We suggest not adding it (except for explicit testing). When there are multiple endpoint models that mix non-normal and normal distributions, the whole problem is shifted to a log-likelihood method for estimation in nlmixr2. 6.6.3 Notes on additive + proportional models There are two different ways to specify additive and proportional models, which we will call combined1 and combined2, the same way that Monolix calls the two distributions (to avoid between software differences in naming). The first, combined1, assumes that the additive and proportional differences are on the standard deviation scale, or: \\[ y=f+(a+b\\times f^c)\\times\\varepsilon \\] The second, combined2, assumes that the additive and proportional differences are combined on a variance scale: \\[ y=f+\\left(\\sqrt{a^2+b^2\\times f^{2c}}\\right)\\times\\varepsilon \\] The default in nlmixr2/rxode2 if not otherwise specified is combined2 since it mirrors how adding 2 normal distributions in statistics will add their variances (not the standard deviations). However, the combined1 can describe the data possibly even better than combined2 so both are possible options in rxode2/nlmixr2. 6.6.4 Distributions of known likelihoods For residuals that are not related to normal, t-distribution or cauchy, often the residual specification is of the form: cmt ~ dbeta(alpha, beta) Where the compartment specification is on the left handed side of the specification. For generalized likelihood you can specify: ll(cmt) ~ llik specification 6.6.5 Ordinal likelihoods Finally, ordinal likelihoods/simulations can be specified in 2 ways. The first is: err ~ c(p0, p1, p2) Here err represents the compartment and p0 is the probability of being in a specific category: Category Probability 1 p0 2 p1 3 p2 4 1-p0-p1-p2 It is up to the model to ensure that the sum of the p values are less than 1. Additionally you can write an arbitrary number of categories in the ordinal model described above. It seems a little off that p0 is the probability for category 1 and sometimes scores are in non-whole numbers. This can be modeled as follows: err ~ c(p0=0, p1=1, p2=2, 3) Here the numeric categories are specified explicitly, and the probabilities remain the same: Category Probability 0 p0 1 p1 2 p2 3 1-p0-p1-p2 6.6.6 General table of supported residual distributions In general all the that are supported are in the following table (available in rxode2::rxResidualError) 6.7 cmt() changing compartment numbers for states The compartment order can be changed with the cmt() syntax in the model. To understand what the cmt() can do you need to understand how rxode2 numbers the compartments. Below is an example of how rxode2 numbers compartments 6.7.1 How rxode2 numbers compartments rxode2 automatically assigns compartment numbers when parsing. For example, with the Mavoglurant PBPK model the following model may be used: library(rxode2) pbpk &lt;- function() { model({ KbBR = exp(lKbBR) KbMU = exp(lKbMU) KbAD = exp(lKbAD) CLint= exp(lCLint + eta.LClint) KbBO = exp(lKbBO) KbRB = exp(lKbRB) ## Regional blood flows # Cardiac output (L/h) from White et al (1968) CO = (187.00*WT^0.81)*60/1000 QHT = 4.0 *CO/100 QBR = 12.0*CO/100 QMU = 17.0*CO/100 QAD = 5.0 *CO/100 QSK = 5.0 *CO/100 QSP = 3.0 *CO/100 QPA = 1.0 *CO/100 QLI = 25.5*CO/100 QST = 1.0 *CO/100 QGU = 14.0*CO/100 # Hepatic artery blood flow QHA = QLI - (QSP + QPA + QST + QGU) QBO = 5.0 *CO/100 QKI = 19.0*CO/100 QRB = CO - (QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI) QLU = QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI + QRB ## Organs&#39; volumes = organs&#39; weights / organs&#39; density VLU = (0.76 *WT/100)/1.051 VHT = (0.47 *WT/100)/1.030 VBR = (2.00 *WT/100)/1.036 VMU = (40.00*WT/100)/1.041 VAD = (21.42*WT/100)/0.916 VSK = (3.71 *WT/100)/1.116 VSP = (0.26 *WT/100)/1.054 VPA = (0.14 *WT/100)/1.045 VLI = (2.57 *WT/100)/1.040 VST = (0.21 *WT/100)/1.050 VGU = (1.44 *WT/100)/1.043 VBO = (14.29*WT/100)/1.990 VKI = (0.44 *WT/100)/1.050 VAB = (2.81 *WT/100)/1.040 VVB = (5.62 *WT/100)/1.040 VRB = (3.86 *WT/100)/1.040 ## Fixed parameters BP = 0.61 # Blood:plasma partition coefficient fup = 0.028 # Fraction unbound in plasma fub = fup/BP # Fraction unbound in blood KbLU = exp(0.8334) KbHT = exp(1.1205) KbSK = exp(-.5238) KbSP = exp(0.3224) KbPA = exp(0.3224) KbLI = exp(1.7604) KbST = exp(0.3224) KbGU = exp(1.2026) KbKI = exp(1.3171) ##----------------------------------------- S15 = VVB*BP/1000 C15 = Venous_Blood/S15 ##----------------------------------------- d/dt(Lungs) = QLU*(Venous_Blood/VVB - Lungs/KbLU/VLU) d/dt(Heart) = QHT*(Arterial_Blood/VAB - Heart/KbHT/VHT) d/dt(Brain) = QBR*(Arterial_Blood/VAB - Brain/KbBR/VBR) d/dt(Muscles) = QMU*(Arterial_Blood/VAB - Muscles/KbMU/VMU) d/dt(Adipose) = QAD*(Arterial_Blood/VAB - Adipose/KbAD/VAD) d/dt(Skin) = QSK*(Arterial_Blood/VAB - Skin/KbSK/VSK) d/dt(Spleen) = QSP*(Arterial_Blood/VAB - Spleen/KbSP/VSP) d/dt(Pancreas) = QPA*(Arterial_Blood/VAB - Pancreas/KbPA/VPA) d/dt(Liver) = QHA*Arterial_Blood/VAB + QSP*Spleen/KbSP/VSP + QPA*Pancreas/KbPA/VPA + QST*Stomach/KbST/VST + QGU*Gut/KbGU/VGU - CLint*fub*Liver/KbLI/VLI - QLI*Liver/KbLI/VLI d/dt(Stomach) = QST*(Arterial_Blood/VAB - Stomach/KbST/VST) d/dt(Gut) = QGU*(Arterial_Blood/VAB - Gut/KbGU/VGU) d/dt(Bones) = QBO*(Arterial_Blood/VAB - Bones/KbBO/VBO) d/dt(Kidneys) = QKI*(Arterial_Blood/VAB - Kidneys/KbKI/VKI) d/dt(Arterial_Blood) = QLU*(Lungs/KbLU/VLU - Arterial_Blood/VAB) d/dt(Venous_Blood) = QHT*Heart/KbHT/VHT + QBR*Brain/KbBR/VBR + QMU*Muscles/KbMU/VMU + QAD*Adipose/KbAD/VAD + QSK*Skin/KbSK/VSK + QLI*Liver/KbLI/VLI + QBO*Bones/KbBO/VBO + QKI*Kidneys/KbKI/VKI + QRB*Rest_of_Body/KbRB/VRB - QLU*Venous_Blood/VVB d/dt(Rest_of_Body) = QRB*(Arterial_Blood/VAB - Rest_of_Body/KbRB/VRB) }) } If you look at the printout, you can see where rxode2 assigned the compartment number(s) pbpk &lt;- pbpk() print(pbpk) #&gt; ── rxode2-based free-form 16-cmt ODE model ───────────────── #&gt; #&gt; States ($state or $stateDf): #&gt; Compartment Number Compartment Name #&gt; 1 1 Lungs #&gt; 2 2 Heart #&gt; 3 3 Brain #&gt; 4 4 Muscles #&gt; 5 5 Adipose #&gt; 6 6 Skin #&gt; 7 7 Spleen #&gt; 8 8 Pancreas #&gt; 9 9 Liver #&gt; 10 10 Stomach #&gt; 11 11 Gut #&gt; 12 12 Bones #&gt; 13 13 Kidneys #&gt; 14 14 Arterial_Blood #&gt; 15 15 Venous_Blood #&gt; 16 16 Rest_of_Body #&gt; ── Model (Normalized Syntax): ── #&gt; function() { #&gt; model({ #&gt; KbBR = exp(lKbBR) #&gt; KbMU = exp(lKbMU) #&gt; KbAD = exp(lKbAD) #&gt; CLint = exp(lCLint + eta.LClint) #&gt; KbBO = exp(lKbBO) #&gt; KbRB = exp(lKbRB) #&gt; CO = (187 * WT^0.81) * 60/1000 #&gt; QHT = 4 * CO/100 #&gt; QBR = 12 * CO/100 #&gt; QMU = 17 * CO/100 #&gt; QAD = 5 * CO/100 #&gt; QSK = 5 * CO/100 #&gt; QSP = 3 * CO/100 #&gt; QPA = 1 * CO/100 #&gt; QLI = 25.5 * CO/100 #&gt; QST = 1 * CO/100 #&gt; QGU = 14 * CO/100 #&gt; QHA = QLI - (QSP + QPA + QST + QGU) #&gt; QBO = 5 * CO/100 #&gt; QKI = 19 * CO/100 #&gt; QRB = CO - (QHT + QBR + QMU + QAD + QSK + QLI + QBO + #&gt; QKI) #&gt; QLU = QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI + #&gt; QRB #&gt; VLU = (0.76 * WT/100)/1.051 #&gt; VHT = (0.47 * WT/100)/1.03 #&gt; VBR = (2 * WT/100)/1.036 #&gt; VMU = (40 * WT/100)/1.041 #&gt; VAD = (21.42 * WT/100)/0.916 #&gt; VSK = (3.71 * WT/100)/1.116 #&gt; VSP = (0.26 * WT/100)/1.054 #&gt; VPA = (0.14 * WT/100)/1.045 #&gt; VLI = (2.57 * WT/100)/1.04 #&gt; VST = (0.21 * WT/100)/1.05 #&gt; VGU = (1.44 * WT/100)/1.043 #&gt; VBO = (14.29 * WT/100)/1.99 #&gt; VKI = (0.44 * WT/100)/1.05 #&gt; VAB = (2.81 * WT/100)/1.04 #&gt; VVB = (5.62 * WT/100)/1.04 #&gt; VRB = (3.86 * WT/100)/1.04 #&gt; BP = 0.61 #&gt; fup = 0.028 #&gt; fub = fup/BP #&gt; KbLU = exp(0.8334) #&gt; KbHT = exp(1.1205) #&gt; KbSK = exp(-0.5238) #&gt; KbSP = exp(0.3224) #&gt; KbPA = exp(0.3224) #&gt; KbLI = exp(1.7604) #&gt; KbST = exp(0.3224) #&gt; KbGU = exp(1.2026) #&gt; KbKI = exp(1.3171) #&gt; S15 = VVB * BP/1000 #&gt; C15 = Venous_Blood/S15 #&gt; d/dt(Lungs) = QLU * (Venous_Blood/VVB - Lungs/KbLU/VLU) #&gt; d/dt(Heart) = QHT * (Arterial_Blood/VAB - Heart/KbHT/VHT) #&gt; d/dt(Brain) = QBR * (Arterial_Blood/VAB - Brain/KbBR/VBR) #&gt; d/dt(Muscles) = QMU * (Arterial_Blood/VAB - Muscles/KbMU/VMU) #&gt; d/dt(Adipose) = QAD * (Arterial_Blood/VAB - Adipose/KbAD/VAD) #&gt; d/dt(Skin) = QSK * (Arterial_Blood/VAB - Skin/KbSK/VSK) #&gt; d/dt(Spleen) = QSP * (Arterial_Blood/VAB - Spleen/KbSP/VSP) #&gt; d/dt(Pancreas) = QPA * (Arterial_Blood/VAB - Pancreas/KbPA/VPA) #&gt; d/dt(Liver) = QHA * Arterial_Blood/VAB + QSP * Spleen/KbSP/VSP + #&gt; QPA * Pancreas/KbPA/VPA + QST * Stomach/KbST/VST + #&gt; QGU * Gut/KbGU/VGU - CLint * fub * Liver/KbLI/VLI - #&gt; QLI * Liver/KbLI/VLI #&gt; d/dt(Stomach) = QST * (Arterial_Blood/VAB - Stomach/KbST/VST) #&gt; d/dt(Gut) = QGU * (Arterial_Blood/VAB - Gut/KbGU/VGU) #&gt; d/dt(Bones) = QBO * (Arterial_Blood/VAB - Bones/KbBO/VBO) #&gt; d/dt(Kidneys) = QKI * (Arterial_Blood/VAB - Kidneys/KbKI/VKI) #&gt; d/dt(Arterial_Blood) = QLU * (Lungs/KbLU/VLU - Arterial_Blood/VAB) #&gt; d/dt(Venous_Blood) = QHT * Heart/KbHT/VHT + QBR * Brain/KbBR/VBR + #&gt; QMU * Muscles/KbMU/VMU + QAD * Adipose/KbAD/VAD + #&gt; QSK * Skin/KbSK/VSK + QLI * Liver/KbLI/VLI + QBO * #&gt; Bones/KbBO/VBO + QKI * Kidneys/KbKI/VKI + QRB * Rest_of_Body/KbRB/VRB - #&gt; QLU * Venous_Blood/VVB #&gt; d/dt(Rest_of_Body) = QRB * (Arterial_Blood/VAB - Rest_of_Body/KbRB/VRB) #&gt; }) #&gt; } You can also see this with the classic rxode2 model. In that case you use the summary() function: pbpk &lt;- pbpk$simulationModel #&gt; using C compiler: ‘gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’ summary(pbpk) #&gt; rxode2 2.0.13.9000 model named rx_81d265cd14191d7bcaa87474579f4737 model (✔ ready). #&gt; DLL: /tmp/RtmpbXPxP7/rxode2/rx_81d265cd14191d7bcaa87474579f4737__.rxd/rx_81d265cd14191d7bcaa87474579f4737_.so #&gt; NULL #&gt; #&gt; Calculated Variables: #&gt; [1] &quot;KbBR&quot; &quot;KbMU&quot; &quot;KbAD&quot; &quot;CLint&quot; &quot;KbBO&quot; &quot;KbRB&quot; &quot;CO&quot; &quot;QHT&quot; &quot;QBR&quot; #&gt; [10] &quot;QMU&quot; &quot;QAD&quot; &quot;QSK&quot; &quot;QSP&quot; &quot;QPA&quot; &quot;QLI&quot; &quot;QST&quot; &quot;QGU&quot; &quot;QHA&quot; #&gt; [19] &quot;QBO&quot; &quot;QKI&quot; &quot;QRB&quot; &quot;QLU&quot; &quot;VLU&quot; &quot;VHT&quot; &quot;VBR&quot; &quot;VMU&quot; &quot;VAD&quot; #&gt; [28] &quot;VSK&quot; &quot;VSP&quot; &quot;VPA&quot; &quot;VLI&quot; &quot;VST&quot; &quot;VGU&quot; &quot;VBO&quot; &quot;VKI&quot; &quot;VAB&quot; #&gt; [37] &quot;VVB&quot; &quot;VRB&quot; &quot;fub&quot; &quot;KbLU&quot; &quot;KbHT&quot; &quot;KbSK&quot; &quot;KbSP&quot; &quot;KbPA&quot; &quot;KbLI&quot; #&gt; [46] &quot;KbST&quot; &quot;KbGU&quot; &quot;KbKI&quot; &quot;S15&quot; &quot;C15&quot; #&gt; ── rxode2 Model Syntax ── #&gt; rxode2({ #&gt; param(lKbBR, lKbMU, lKbAD, lCLint, eta.LClint, lKbBO, lKbRB, #&gt; WT) #&gt; KbBR = exp(lKbBR) #&gt; KbMU = exp(lKbMU) #&gt; KbAD = exp(lKbAD) #&gt; CLint = exp(lCLint + eta.LClint) #&gt; KbBO = exp(lKbBO) #&gt; KbRB = exp(lKbRB) #&gt; CO = (187 * WT^0.81) * 60/1000 #&gt; QHT = 4 * CO/100 #&gt; QBR = 12 * CO/100 #&gt; QMU = 17 * CO/100 #&gt; QAD = 5 * CO/100 #&gt; QSK = 5 * CO/100 #&gt; QSP = 3 * CO/100 #&gt; QPA = 1 * CO/100 #&gt; QLI = 25.5 * CO/100 #&gt; QST = 1 * CO/100 #&gt; QGU = 14 * CO/100 #&gt; QHA = QLI - (QSP + QPA + QST + QGU) #&gt; QBO = 5 * CO/100 #&gt; QKI = 19 * CO/100 #&gt; QRB = CO - (QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI) #&gt; QLU = QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI + QRB #&gt; VLU = (0.76 * WT/100)/1.051 #&gt; VHT = (0.47 * WT/100)/1.03 #&gt; VBR = (2 * WT/100)/1.036 #&gt; VMU = (40 * WT/100)/1.041 #&gt; VAD = (21.42 * WT/100)/0.916 #&gt; VSK = (3.71 * WT/100)/1.116 #&gt; VSP = (0.26 * WT/100)/1.054 #&gt; VPA = (0.14 * WT/100)/1.045 #&gt; VLI = (2.57 * WT/100)/1.04 #&gt; VST = (0.21 * WT/100)/1.05 #&gt; VGU = (1.44 * WT/100)/1.043 #&gt; VBO = (14.29 * WT/100)/1.99 #&gt; VKI = (0.44 * WT/100)/1.05 #&gt; VAB = (2.81 * WT/100)/1.04 #&gt; VVB = (5.62 * WT/100)/1.04 #&gt; VRB = (3.86 * WT/100)/1.04 #&gt; BP = 0.61 #&gt; fup = 0.028 #&gt; fub = fup/BP #&gt; KbLU = exp(0.8334) #&gt; KbHT = exp(1.1205) #&gt; KbSK = exp(-0.5238) #&gt; KbSP = exp(0.3224) #&gt; KbPA = exp(0.3224) #&gt; KbLI = exp(1.7604) #&gt; KbST = exp(0.3224) #&gt; KbGU = exp(1.2026) #&gt; KbKI = exp(1.3171) #&gt; S15 = VVB * BP/1000 #&gt; C15 = Venous_Blood/S15 #&gt; d/dt(Lungs) = QLU * (Venous_Blood/VVB - Lungs/KbLU/VLU) #&gt; d/dt(Heart) = QHT * (Arterial_Blood/VAB - Heart/KbHT/VHT) #&gt; d/dt(Brain) = QBR * (Arterial_Blood/VAB - Brain/KbBR/VBR) #&gt; d/dt(Muscles) = QMU * (Arterial_Blood/VAB - Muscles/KbMU/VMU) #&gt; d/dt(Adipose) = QAD * (Arterial_Blood/VAB - Adipose/KbAD/VAD) #&gt; d/dt(Skin) = QSK * (Arterial_Blood/VAB - Skin/KbSK/VSK) #&gt; d/dt(Spleen) = QSP * (Arterial_Blood/VAB - Spleen/KbSP/VSP) #&gt; d/dt(Pancreas) = QPA * (Arterial_Blood/VAB - Pancreas/KbPA/VPA) #&gt; d/dt(Liver) = QHA * Arterial_Blood/VAB + QSP * Spleen/KbSP/VSP + #&gt; QPA * Pancreas/KbPA/VPA + QST * Stomach/KbST/VST + QGU * #&gt; Gut/KbGU/VGU - CLint * fub * Liver/KbLI/VLI - QLI * Liver/KbLI/VLI #&gt; d/dt(Stomach) = QST * (Arterial_Blood/VAB - Stomach/KbST/VST) #&gt; d/dt(Gut) = QGU * (Arterial_Blood/VAB - Gut/KbGU/VGU) #&gt; d/dt(Bones) = QBO * (Arterial_Blood/VAB - Bones/KbBO/VBO) #&gt; d/dt(Kidneys) = QKI * (Arterial_Blood/VAB - Kidneys/KbKI/VKI) #&gt; d/dt(Arterial_Blood) = QLU * (Lungs/KbLU/VLU - Arterial_Blood/VAB) #&gt; d/dt(Venous_Blood) = QHT * Heart/KbHT/VHT + QBR * Brain/KbBR/VBR + #&gt; QMU * Muscles/KbMU/VMU + QAD * Adipose/KbAD/VAD + QSK * #&gt; Skin/KbSK/VSK + QLI * Liver/KbLI/VLI + QBO * Bones/KbBO/VBO + #&gt; QKI * Kidneys/KbKI/VKI + QRB * Rest_of_Body/KbRB/VRB - #&gt; QLU * Venous_Blood/VVB #&gt; d/dt(Rest_of_Body) = QRB * (Arterial_Blood/VAB - Rest_of_Body/KbRB/VRB) #&gt; }) In this case, Venous_Blood is assigned to compartment 15. Figuring this out can be inconvenient and also lead to re-numbering compartment in simulation or estimation datasets. While it is easy and probably clearer to specify the compartment by name, other tools only support compartment numbers. Therefore, having a way to number compartment easily can lead to less data modification between multiple tools. 6.7.2 Changing compartments by pre-declaring with cmt() To add the compartments to the rxode2 model in the order you desire you simply need to pre-declare the compartments with cmt. For example specifying is Venous_Blood and Skin to be the 1st and 2nd compartments, respectively, is simple: pbpk2 &lt;- function() { model({ ## Now this is the first compartment, ie cmt=1 cmt(Venous_Blood) ## Skin may be a compartment you wish to dose to as well, ## so it is now cmt=2 cmt(Skin) KbBR = exp(lKbBR) KbMU = exp(lKbMU) KbAD = exp(lKbAD) CLint= exp(lCLint + eta.LClint) KbBO = exp(lKbBO) KbRB = exp(lKbRB) ## Regional blood flows # Cardiac output (L/h) from White et al (1968)m CO = (187.00*WT^0.81)*60/1000; QHT = 4.0 *CO/100; QBR = 12.0*CO/100; QMU = 17.0*CO/100; QAD = 5.0 *CO/100; QSK = 5.0 *CO/100; QSP = 3.0 *CO/100; QPA = 1.0 *CO/100; QLI = 25.5*CO/100; QST = 1.0 *CO/100; QGU = 14.0*CO/100; QHA = QLI - (QSP + QPA + QST + QGU); # Hepatic artery blood flow QBO = 5.0 *CO/100; QKI = 19.0*CO/100; QRB = CO - (QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI); QLU = QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI + QRB; ## Organs&#39; volumes = organs&#39; weights / organs&#39; density VLU = (0.76 *WT/100)/1.051; VHT = (0.47 *WT/100)/1.030; VBR = (2.00 *WT/100)/1.036; VMU = (40.00*WT/100)/1.041; VAD = (21.42*WT/100)/0.916; VSK = (3.71 *WT/100)/1.116; VSP = (0.26 *WT/100)/1.054; VPA = (0.14 *WT/100)/1.045; VLI = (2.57 *WT/100)/1.040; VST = (0.21 *WT/100)/1.050; VGU = (1.44 *WT/100)/1.043; VBO = (14.29*WT/100)/1.990; VKI = (0.44 *WT/100)/1.050; VAB = (2.81 *WT/100)/1.040; VVB = (5.62 *WT/100)/1.040; VRB = (3.86 *WT/100)/1.040; ## Fixed parameters BP = 0.61; # Blood:plasma partition coefficient fup = 0.028; # Fraction unbound in plasma fub = fup/BP; # Fraction unbound in blood KbLU = exp(0.8334); KbHT = exp(1.1205); KbSK = exp(-.5238); KbSP = exp(0.3224); KbPA = exp(0.3224); KbLI = exp(1.7604); KbST = exp(0.3224); KbGU = exp(1.2026); KbKI = exp(1.3171); ##----------------------------------------- S15 = VVB*BP/1000; C15 = Venous_Blood/S15 ##----------------------------------------- d/dt(Lungs) = QLU*(Venous_Blood/VVB - Lungs/KbLU/VLU); d/dt(Heart) = QHT*(Arterial_Blood/VAB - Heart/KbHT/VHT); d/dt(Brain) = QBR*(Arterial_Blood/VAB - Brain/KbBR/VBR); d/dt(Muscles) = QMU*(Arterial_Blood/VAB - Muscles/KbMU/VMU); d/dt(Adipose) = QAD*(Arterial_Blood/VAB - Adipose/KbAD/VAD); d/dt(Skin) = QSK*(Arterial_Blood/VAB - Skin/KbSK/VSK); d/dt(Spleen) = QSP*(Arterial_Blood/VAB - Spleen/KbSP/VSP); d/dt(Pancreas) = QPA*(Arterial_Blood/VAB - Pancreas/KbPA/VPA); d/dt(Liver) = QHA*Arterial_Blood/VAB + QSP*Spleen/KbSP/VSP + QPA*Pancreas/KbPA/VPA + QST*Stomach/KbST/VST + QGU*Gut/KbGU/VGU - CLint*fub*Liver/KbLI/VLI - QLI*Liver/KbLI/VLI; d/dt(Stomach) = QST*(Arterial_Blood/VAB - Stomach/KbST/VST); d/dt(Gut) = QGU*(Arterial_Blood/VAB - Gut/KbGU/VGU); d/dt(Bones) = QBO*(Arterial_Blood/VAB - Bones/KbBO/VBO); d/dt(Kidneys) = QKI*(Arterial_Blood/VAB - Kidneys/KbKI/VKI); d/dt(Arterial_Blood) = QLU*(Lungs/KbLU/VLU - Arterial_Blood/VAB); d/dt(Venous_Blood) = QHT*Heart/KbHT/VHT + QBR*Brain/KbBR/VBR + QMU*Muscles/KbMU/VMU + QAD*Adipose/KbAD/VAD + QSK*Skin/KbSK/VSK + QLI*Liver/KbLI/VLI + QBO*Bones/KbBO/VBO + QKI*Kidneys/KbKI/VKI + QRB*Rest_of_Body/KbRB/VRB - QLU*Venous_Blood/VVB; d/dt(Rest_of_Body) = QRB*(Arterial_Blood/VAB - Rest_of_Body/KbRB/VRB); }) } You can see this change in the simple printout pbpk2 &lt;- pbpk2() pbpk2 #&gt; ── rxode2-based free-form 16-cmt ODE model ───────────────── #&gt; #&gt; States ($state or $stateDf): #&gt; Compartment Number Compartment Name #&gt; 1 1 Venous_Blood #&gt; 2 2 Skin #&gt; 3 3 Lungs #&gt; 4 4 Heart #&gt; 5 5 Brain #&gt; 6 6 Muscles #&gt; 7 7 Adipose #&gt; 8 8 Spleen #&gt; 9 9 Pancreas #&gt; 10 10 Liver #&gt; 11 11 Stomach #&gt; 12 12 Gut #&gt; 13 13 Bones #&gt; 14 14 Kidneys #&gt; 15 15 Arterial_Blood #&gt; 16 16 Rest_of_Body #&gt; ── Model (Normalized Syntax): ── #&gt; function() { #&gt; model({ #&gt; cmt(Venous_Blood) #&gt; cmt(Skin) #&gt; KbBR = exp(lKbBR) #&gt; KbMU = exp(lKbMU) #&gt; KbAD = exp(lKbAD) #&gt; CLint = exp(lCLint + eta.LClint) #&gt; KbBO = exp(lKbBO) #&gt; KbRB = exp(lKbRB) #&gt; CO = (187 * WT^0.81) * 60/1000 #&gt; QHT = 4 * CO/100 #&gt; QBR = 12 * CO/100 #&gt; QMU = 17 * CO/100 #&gt; QAD = 5 * CO/100 #&gt; QSK = 5 * CO/100 #&gt; QSP = 3 * CO/100 #&gt; QPA = 1 * CO/100 #&gt; QLI = 25.5 * CO/100 #&gt; QST = 1 * CO/100 #&gt; QGU = 14 * CO/100 #&gt; QHA = QLI - (QSP + QPA + QST + QGU) #&gt; QBO = 5 * CO/100 #&gt; QKI = 19 * CO/100 #&gt; QRB = CO - (QHT + QBR + QMU + QAD + QSK + QLI + QBO + #&gt; QKI) #&gt; QLU = QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI + #&gt; QRB #&gt; VLU = (0.76 * WT/100)/1.051 #&gt; VHT = (0.47 * WT/100)/1.03 #&gt; VBR = (2 * WT/100)/1.036 #&gt; VMU = (40 * WT/100)/1.041 #&gt; VAD = (21.42 * WT/100)/0.916 #&gt; VSK = (3.71 * WT/100)/1.116 #&gt; VSP = (0.26 * WT/100)/1.054 #&gt; VPA = (0.14 * WT/100)/1.045 #&gt; VLI = (2.57 * WT/100)/1.04 #&gt; VST = (0.21 * WT/100)/1.05 #&gt; VGU = (1.44 * WT/100)/1.043 #&gt; VBO = (14.29 * WT/100)/1.99 #&gt; VKI = (0.44 * WT/100)/1.05 #&gt; VAB = (2.81 * WT/100)/1.04 #&gt; VVB = (5.62 * WT/100)/1.04 #&gt; VRB = (3.86 * WT/100)/1.04 #&gt; BP = 0.61 #&gt; fup = 0.028 #&gt; fub = fup/BP #&gt; KbLU = exp(0.8334) #&gt; KbHT = exp(1.1205) #&gt; KbSK = exp(-0.5238) #&gt; KbSP = exp(0.3224) #&gt; KbPA = exp(0.3224) #&gt; KbLI = exp(1.7604) #&gt; KbST = exp(0.3224) #&gt; KbGU = exp(1.2026) #&gt; KbKI = exp(1.3171) #&gt; S15 = VVB * BP/1000 #&gt; C15 = Venous_Blood/S15 #&gt; d/dt(Lungs) = QLU * (Venous_Blood/VVB - Lungs/KbLU/VLU) #&gt; d/dt(Heart) = QHT * (Arterial_Blood/VAB - Heart/KbHT/VHT) #&gt; d/dt(Brain) = QBR * (Arterial_Blood/VAB - Brain/KbBR/VBR) #&gt; d/dt(Muscles) = QMU * (Arterial_Blood/VAB - Muscles/KbMU/VMU) #&gt; d/dt(Adipose) = QAD * (Arterial_Blood/VAB - Adipose/KbAD/VAD) #&gt; d/dt(Skin) = QSK * (Arterial_Blood/VAB - Skin/KbSK/VSK) #&gt; d/dt(Spleen) = QSP * (Arterial_Blood/VAB - Spleen/KbSP/VSP) #&gt; d/dt(Pancreas) = QPA * (Arterial_Blood/VAB - Pancreas/KbPA/VPA) #&gt; d/dt(Liver) = QHA * Arterial_Blood/VAB + QSP * Spleen/KbSP/VSP + #&gt; QPA * Pancreas/KbPA/VPA + QST * Stomach/KbST/VST + #&gt; QGU * Gut/KbGU/VGU - CLint * fub * Liver/KbLI/VLI - #&gt; QLI * Liver/KbLI/VLI #&gt; d/dt(Stomach) = QST * (Arterial_Blood/VAB - Stomach/KbST/VST) #&gt; d/dt(Gut) = QGU * (Arterial_Blood/VAB - Gut/KbGU/VGU) #&gt; d/dt(Bones) = QBO * (Arterial_Blood/VAB - Bones/KbBO/VBO) #&gt; d/dt(Kidneys) = QKI * (Arterial_Blood/VAB - Kidneys/KbKI/VKI) #&gt; d/dt(Arterial_Blood) = QLU * (Lungs/KbLU/VLU - Arterial_Blood/VAB) #&gt; d/dt(Venous_Blood) = QHT * Heart/KbHT/VHT + QBR * Brain/KbBR/VBR + #&gt; QMU * Muscles/KbMU/VMU + QAD * Adipose/KbAD/VAD + #&gt; QSK * Skin/KbSK/VSK + QLI * Liver/KbLI/VLI + QBO * #&gt; Bones/KbBO/VBO + QKI * Kidneys/KbKI/VKI + QRB * Rest_of_Body/KbRB/VRB - #&gt; QLU * Venous_Blood/VVB #&gt; d/dt(Rest_of_Body) = QRB * (Arterial_Blood/VAB - Rest_of_Body/KbRB/VRB) #&gt; }) #&gt; } The first two compartments are Venous_Blood followed by Skin. 6.7.3 Appending compartments to the model with cmt() You can also append “compartments” to the model. Because of the ODE solving internals, you cannot add fake compartments to the model until after all the differential equations are defined. For example this is legal: ode.1c.ka &lt;- function(){ model({ C2 = center/V d / dt(depot) = -KA * depot d/dt(center) = KA * depot - CL*C2 cmt(eff) }) } ode.1c.ka &lt;- ode.1c.ka() print(ode.1c.ka) #&gt; ── rxode2-based free-form 2-cmt ODE model ────────────────── #&gt; #&gt; States ($state or $stateDf): #&gt; Compartment Number Compartment Name #&gt; 1 1 depot #&gt; 2 2 center #&gt; ── Model (Normalized Syntax): ── #&gt; function() { #&gt; model({ #&gt; C2 = center/V #&gt; d/dt(depot) = -KA * depot #&gt; d/dt(center) = KA * depot - CL * C2 #&gt; cmt(eff) #&gt; }) #&gt; } You can see this more clearly with the underlying classic rxode2 model: ode.1c.ka$simulationModel #&gt; using C compiler: ‘gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’ #&gt; rxode2 2.0.13.9000 model named rx_5aa9aaa0d2b031c6e0671346ef0361f7 model (✔ ready). #&gt; x$state: depot, center #&gt; x$stateExtra: eff #&gt; x$params: V, KA, CL #&gt; x$lhs: C2 But compartments defined before all the differential equations is not supported; So the model below: ode.1c.ka &lt;- rxode2({ cmt(eff) C2 = center/V; d / dt(depot) = -KA * depot d/dt(center) = KA * depot - CL*C2 }) will give an error: Error in rxModelVars_(obj) : Evaluation error: Compartment &#39;eff&#39; needs differential equations defined. "],["events.html", "Chapter 7 rxode2 events 7.1 rxode2 event tables 7.2 Bolus/Additive Doses 7.3 Infusion Doses 7.4 Steady State 7.5 Reset Events 7.6 Turning off compartments 7.7 Classic rxode2 events 7.8 Datasets for rxode2 &amp; nlmixr 7.9 Columns Described by Type of Use 7.10 Details for Specific Dataset Columns", " Chapter 7 rxode2 events 7.1 rxode2 event tables In general, rxode2 event tables follow NONMEM dataset convention with the exceptions: The compartment data item (cmt) can be a string/factor with compartment names You may turn off a compartment with a negative compartment number or “-cmt” where cmt is the compartment name. The compartment data item (cmt) can still be a number, the number of the compartment is defined by the appearance of the compartment name in the model. This can be tedious to count, so you can specify compartment numbers easier by using the cmt(cmtName) at the beginning of the model. An additional column, dur can specify the duration of infusions; Bioavailability changes will change the rate of infusion since dur/amt are fixed in the input data. Similarly, when specifying rate/amt for an infusion, the bioavailability will change the infusion duration since rate/amt are fixed in the input data. Some infrequent NONMEM columns are not supported: pcmt, call. NONMEM-style events are supported (0: Observation, 1: Dose, 2: Other, 3: Reset, 4: Reset+Dose). Additional events are supported: evid=5 or replace event; This replaces the value of a compartment with the value specified in the amt column. This is equivalent to deSolve=replace. evid=6 or multiply event; This multiplies the value in the compartment with the value specified by the amt column. This is equivalent to deSolve=multiply. evid=7 or transit compartment model/phantom event. This puts the dose in the dose() function and calculates time since last dose tad() but doesn’t actually put the dose in the compartment. This allows the transit() function to easily apply to the compartment. Here are the legal entries to a data table: Data Item Meaning Notes id Individual identifier Can be a integer, factor, character, or numeric time Individual time Numeric for each time. amt dose amount Positive for doses zero/NA for observations rate infusion rate When specified the infusion duration will be dur=amt/rate rate = -1, rate modeled; rate = -2, duration modeled dur infusion duration When specified the infusion rate will be rate = amt/dur evid event ID 0=Observation; 1=Dose; 2=Other; 3=Reset; 4=Reset+Dose; 5=Replace; 6=Multiply;7=Transit cmt Compartment Represents compartment #/name for dose/observation ss Steady State Flag 0 = non-steady-state; 1=steady state; 2=steady state +prior states ii Inter-dose Interval Time between doses. addl # of additional doses Number of doses like the current dose. Other notes: The evid can be the classic RxODE (described here) or the NONMEM-style evid described above. NONMEM’s DV is not required; rxode2 is a ODE solving framework. NONMEM’s MDV is not required, since it is captured in EVID. Instead of NONMEM-compatible data, it can accept deSolve compatible data-frames. When returning the rxode2 solved data-set there are a few additional event ids (EVID) that you may see depending on the solving options: EVID = -1 is when a modeled rate ends (corresponds to rate = -1) EVID = -2 is when a modeled duration ends (corresponds to rate=-2) EVID = -10 when a rate specified zero-order infusion ends (corresponds to rate &gt; 0) EVID = -20 when a duration specified zero-order infusion ends (corresponds to dur &gt; 0) EVID = 101, 102, 103,... These correspond to the 1, 2, 3, … modeled time (mtime). These can only be accessed when solving with the option combination addDosing=TRUE and subsetNonmem=FALSE. If you want to see the classic EVID equivalents you can use addDosing=NA. To illustrate the event types we will use the model from the original rxode2 tutorial. library(rxode2) ### Model from rxode2 tutorial m1 &lt;- function() { ini({ KA &lt;- 2.94E-01 CL &lt;- 1.86E+01 V2 &lt;- 4.02E+01 Q &lt;- 1.05E+01 V3 &lt;- 2.97E+02 Kin &lt;- 1 Kout &lt;- 1 EC50 &lt;- 200 ## Added modeled bioavaiblity, duration and rate fdepot &lt;- 1 durDepot &lt;- 8 rateDepot &lt;- 1250 }) model({ C2 &lt;- centr/V2 C3 &lt;- peri/V3 d/dt(depot) &lt;- -KA*depot f(depot) &lt;- fdepot dur(depot) &lt;- durDepot rate(depot) &lt;- rateDepot d/dt(centr) &lt;- KA*depot - CL*C2 - Q*C2 + Q*C3 d/dt(peri) &lt;- Q*C2 - Q*C3 d/dt(eff) &lt;- Kin - Kout*(1-C2/(EC50+C2))*eff eff(0) &lt;- 1 }) } 7.2 Bolus/Additive Doses A bolus dose is the default type of dose in rxode2 and only requires the amt/dose. Note that this uses the convenience function et() described in the rxode2 event tables ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12,until=24) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ── EventTable with 101 records ── #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 100 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 101 × 5 #&gt; time amt ii addl evid #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 NA NA NA 0:Observation #&gt; 2 0 10000 12 2 1:Dose (Add) #&gt; 3 0.242 NA NA NA 0:Observation #&gt; 4 0.485 NA NA NA 0:Observation #&gt; 5 0.727 NA NA NA 0:Observation #&gt; 6 0.970 NA NA NA 0:Observation #&gt; 7 1.21 NA NA NA 0:Observation #&gt; 8 1.45 NA NA NA 0:Observation #&gt; 9 1.70 NA NA NA 0:Observation #&gt; 10 1.94 NA NA NA 0:Observation #&gt; # ℹ 91 more rows rxSolve(m1, ev) %&gt;% plot(C2) + xlab(&quot;Time&quot;) #&gt; using C compiler: ‘gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’ 7.3 Infusion Doses There are a few different type of infusions that rxode2 supports: Constant Rate Infusion (rate) Constant Duration Infusion (dur) Estimated Rate of Infusion Estimated Duration of Infusion 7.3.1 Constant Infusion (in terms of duration and rate) The next type of event is an infusion; There are two ways to specify an infusion; The first is the dur keyword. An example of this is: ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12,until=24, dur=8) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ── EventTable with 101 records ── #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 100 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 101 × 6 #&gt; time amt ii addl evid dur #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; [h] #&gt; 1 0 NA NA NA 0:Observation NA #&gt; 2 0 10000 12 2 1:Dose (Add) 8 #&gt; 3 0.242 NA NA NA 0:Observation NA #&gt; 4 0.485 NA NA NA 0:Observation NA #&gt; 5 0.727 NA NA NA 0:Observation NA #&gt; 6 0.970 NA NA NA 0:Observation NA #&gt; 7 1.21 NA NA NA 0:Observation NA #&gt; 8 1.45 NA NA NA 0:Observation NA #&gt; 9 1.70 NA NA NA 0:Observation NA #&gt; 10 1.94 NA NA NA 0:Observation NA #&gt; # ℹ 91 more rows rxSolve(m1, ev) %&gt;% plot(depot, C2) + xlab(&quot;Time&quot;) It can be also specified by the rate component: ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12,until=24, rate=10000/8) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ── EventTable with 101 records ── #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 100 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 101 × 6 #&gt; time amt rate ii addl evid #&gt; [h] &lt;dbl&gt; &lt;rate/dur&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 NA NA NA NA 0:Observation #&gt; 2 0 10000 1250 12 2 1:Dose (Add) #&gt; 3 0.242 NA NA NA NA 0:Observation #&gt; 4 0.485 NA NA NA NA 0:Observation #&gt; 5 0.727 NA NA NA NA 0:Observation #&gt; 6 0.970 NA NA NA NA 0:Observation #&gt; 7 1.21 NA NA NA NA 0:Observation #&gt; 8 1.45 NA NA NA NA 0:Observation #&gt; 9 1.70 NA NA NA NA 0:Observation #&gt; 10 1.94 NA NA NA NA 0:Observation #&gt; # ℹ 91 more rows rxSolve(m1, ev) %&gt;% plot(depot, C2) + xlab(&quot;Time&quot;) These are the same with the exception of how bioavailability changes the infusion. In the case of modeling rate, a bioavailability decrease, decreases the infusion duration, as in NONMEM. For example: rxSolve(m1, ev, c(fdepot=0.25)) %&gt;% plot(depot, C2) + xlab(&quot;Time&quot;) Similarly increasing the bioavailability increases the infusion duration. rxSolve(m1, ev, c(fdepot=1.25)) %&gt;% plot(depot, C2) + xlab(&quot;Time&quot;) The rationale for this behavior is that the rate and amt are specified by the event table, so the only thing that can change with a bioavailability increase is the duration of the infusion. If you specify the amt and dur components in the event table, bioavailability changes affect the rate of infusion. ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12,until=24, dur=8) %&gt;% et(seq(0, 24, length.out=100)) You can see the side-by-side comparison of bioavailability changes affecting rate instead of duration with these records in the following plots: library(ggplot2) library(patchwork) p1 &lt;- rxSolve(m1, ev, c(fdepot=1.25)) %&gt;% plot(depot) + xlab(&quot;Time&quot;) + ylim(0,5000) p2 &lt;- rxSolve(m1, ev, c(fdepot=0.25)) %&gt;% plot(depot) + xlab(&quot;Time&quot;)+ ylim(0,5000) ### Use patchwork syntax to combine plots p1 * p2 7.3.2 Modeled Rate and Duration of Infusion You can model the duration, which is equivalent to NONMEM’s rate=-2. ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12,until=24, rate=-2) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ── EventTable with 101 records ── #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 100 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 101 × 6 #&gt; time amt rate ii addl evid #&gt; [h] &lt;dbl&gt; &lt;rate/dur&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 NA NA NA NA 0:Observation #&gt; 2 0 10000 -2:dur 12 2 1:Dose (Add) #&gt; 3 0.242 NA NA NA NA 0:Observation #&gt; 4 0.485 NA NA NA NA 0:Observation #&gt; 5 0.727 NA NA NA NA 0:Observation #&gt; 6 0.970 NA NA NA NA 0:Observation #&gt; 7 1.21 NA NA NA NA 0:Observation #&gt; 8 1.45 NA NA NA NA 0:Observation #&gt; 9 1.70 NA NA NA NA 0:Observation #&gt; 10 1.94 NA NA NA NA 0:Observation #&gt; # ℹ 91 more rows rxSolve(m1, ev, c(durDepot=7)) %&gt;% plot(depot, C2) + xlab(&quot;Time&quot;) Similarly, you may also model rate. This is equivalent to NONMEM’s rate=-1 and is how rxode2’s event table specifies the data item as well. ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12,until=24, rate=-1) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ── EventTable with 101 records ── #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 100 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 101 × 6 #&gt; time amt rate ii addl evid #&gt; [h] &lt;dbl&gt; &lt;rate/dur&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 NA NA NA NA 0:Observation #&gt; 2 0 10000 -1:rate 12 2 1:Dose (Add) #&gt; 3 0.242 NA NA NA NA 0:Observation #&gt; 4 0.485 NA NA NA NA 0:Observation #&gt; 5 0.727 NA NA NA NA 0:Observation #&gt; 6 0.970 NA NA NA NA 0:Observation #&gt; 7 1.21 NA NA NA NA 0:Observation #&gt; 8 1.45 NA NA NA NA 0:Observation #&gt; 9 1.70 NA NA NA NA 0:Observation #&gt; 10 1.94 NA NA NA NA 0:Observation #&gt; # ℹ 91 more rows rxSolve(m1, ev, c(rateDepot=10000/3)) %&gt;% plot(depot, C2) + xlab(&quot;Time&quot;) 7.4 Steady State These doses are solved until a steady state is reached with a constant inter-dose interval. ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12, ss=1) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ── EventTable with 101 records ── #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 100 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; ── First part of x: ── #&gt; # A tibble: 101 × 5 #&gt; time amt ii evid ss #&gt; [h] &lt;dbl&gt; [h] &lt;evid&gt; &lt;int&gt; #&gt; 1 0 NA NA 0:Observation NA #&gt; 2 0 10000 12 1:Dose (Add) 1 #&gt; 3 0.242 NA NA 0:Observation NA #&gt; 4 0.485 NA NA 0:Observation NA #&gt; 5 0.727 NA NA 0:Observation NA #&gt; 6 0.970 NA NA 0:Observation NA #&gt; 7 1.21 NA NA 0:Observation NA #&gt; 8 1.45 NA NA 0:Observation NA #&gt; 9 1.70 NA NA 0:Observation NA #&gt; 10 1.94 NA NA 0:Observation NA #&gt; # ℹ 91 more rows rxSolve(m1, ev) %&gt;% plot(C2) 7.4.1 Steady state for complex dosing By using the ss=2 flag, you can use the super-positioning principle in linear kinetics to get steady state nonstandard dosing (i.e. morning 100 mg vs evening 150 mg). This is done by: Saving all the state values Resetting all the states and solving the system to steady state Adding back all the prior state values ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=24, ss=1) %&gt;% et(time=12, amt=15000, ii=24, ss=2) %&gt;% et(time=24, amt=10000, ii=24, addl=3) %&gt;% et(time=36, amt=15000, ii=24, addl=3) %&gt;% et(seq(0, 64, length.out=500)) library(ggplot2) rxSolve(m1, ev,maxsteps=10000) %&gt;% plot(C2) + annotate(&quot;rect&quot;, xmin=0, xmax=24, ymin=-Inf, ymax=Inf, alpha=0.2) + annotate(&quot;text&quot;, x=12.5, y=7, label=&quot;Initial Steady State Period&quot;) + annotate(&quot;text&quot;, x=44, y=7, label=&quot;Steady State AM/PM dosing&quot;) You can see that it takes a full dose cycle to reach the true complex steady state dosing. 7.4.2 Steady state for constant infusion or zero order processes The last type of steady state that rxode2 supports is steady-state constant infusion rate. This can be specified the same way as NONMEM, that is: No inter-dose interval ii=0 A steady state dose, ie ss=1 Either a positive rate (rate&gt;0) or a estimated rate rate=-1. A zero dose, ie amt=0 Once the steady-state constant infusion is achieved, the infusion is turned off when using this record, just like NONMEM. Note that rate=-2 where we model the duration of infusion doesn’t make much sense since we are solving the infusion until steady state. The duration is specified by the steady state solution. Also note that bioavailability changes on this steady state infusion also do not make sense because they neither change the rate or the duration of the steady state infusion. Hence modeled bioavailability on this type of dosing event is ignored. Here is an example: ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=0, ss=1,rate=10000/8) p1 &lt;- rxSolve(m1, ev) %&gt;% plot(C2, eff) ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=200000, rate=10000/8) %&gt;% et(0, 250, length.out=1000) p2 &lt;- rxSolve(m1, ev) %&gt;% plot(C2, eff) library(patchwork) p1 / p2 Not only can this be used for PK, it can be used for steady-state disease processes. 7.5 Reset Events Reset events are implemented by evid=3 or evid=reset, for reset and evid=4 for reset and dose. ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12, addl=3) %&gt;% et(time=6, evid=reset) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ── EventTable with 102 records ── #&gt; 2 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 100 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 102 × 5 #&gt; time amt ii addl evid #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 NA NA NA 0:Observation #&gt; 2 0 10000 12 3 1:Dose (Add) #&gt; 3 0.242 NA NA NA 0:Observation #&gt; 4 0.485 NA NA NA 0:Observation #&gt; 5 0.727 NA NA NA 0:Observation #&gt; 6 0.970 NA NA NA 0:Observation #&gt; 7 1.21 NA NA NA 0:Observation #&gt; 8 1.45 NA NA NA 0:Observation #&gt; 9 1.70 NA NA NA 0:Observation #&gt; 10 1.94 NA NA NA 0:Observation #&gt; # ℹ 92 more rows The solving show what happens in this system when the system is reset at 6 hours post-dose. rxSolve(m1, ev) %&gt;% plot(depot,C2, eff) You can see all the compartments are reset to their initial values. The next dose start the dosing cycle over. ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12, addl=3) %&gt;% et(time=6, amt=10000, evid=4) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ── EventTable with 102 records ── #&gt; 2 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 100 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 102 × 5 #&gt; time amt ii addl evid #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 NA NA NA 0:Observation #&gt; 2 0 10000 12 3 1:Dose (Add) #&gt; 3 0.242 NA NA NA 0:Observation #&gt; 4 0.485 NA NA NA 0:Observation #&gt; 5 0.727 NA NA NA 0:Observation #&gt; 6 0.970 NA NA NA 0:Observation #&gt; 7 1.21 NA NA NA 0:Observation #&gt; 8 1.45 NA NA NA 0:Observation #&gt; 9 1.70 NA NA NA 0:Observation #&gt; 10 1.94 NA NA NA 0:Observation #&gt; # ℹ 92 more rows In this case, the whole system is reset and the dose is given rxSolve(m1, ev) %&gt;% plot(depot,C2, eff) 7.6 Turning off compartments You may also turn off a compartment, which is similar to a reset event. ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12, addl=3) %&gt;% et(time=6, cmt=&quot;-depot&quot;, evid=2) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ── EventTable with 102 records ── #&gt; 2 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 100 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 102 × 6 #&gt; time cmt amt ii addl evid #&gt; [h] &lt;chr&gt; &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 (obs) NA NA NA 0:Observation #&gt; 2 0 (default) 10000 12 3 1:Dose (Add) #&gt; 3 0.242 (obs) NA NA NA 0:Observation #&gt; 4 0.485 (obs) NA NA NA 0:Observation #&gt; 5 0.727 (obs) NA NA NA 0:Observation #&gt; 6 0.970 (obs) NA NA NA 0:Observation #&gt; 7 1.21 (obs) NA NA NA 0:Observation #&gt; 8 1.45 (obs) NA NA NA 0:Observation #&gt; 9 1.70 (obs) NA NA NA 0:Observation #&gt; 10 1.94 (obs) NA NA NA 0:Observation #&gt; # ℹ 92 more rows Solving shows what this does in the system: rxSolve(m1, ev) %&gt;% plot(depot,C2, eff) In this case, the depot is turned off, and the depot compartment concentrations are set to the initial values but the other compartment concentrations/levels are not reset. When another dose to the depot is administered the depot compartment is turned back on. Note that a dose to a compartment only turns back on the compartment that was dosed. Hence if you turn off the effect compartment, it continues to be off after another dose to the depot. ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12, addl=3) %&gt;% et(time=6, cmt=&quot;-eff&quot;, evid=2) %&gt;% et(seq(0, 24, length.out=100)) rxSolve(m1, ev) %&gt;% plot(depot,C2, eff) To turn back on the compartment, a zero-dose to the compartment or a evid=2 with the compartment would be needed. ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12, addl=3) %&gt;% et(time=6, cmt=&quot;-eff&quot;, evid=2) %&gt;% et(time=12,cmt=&quot;eff&quot;,evid=2) %&gt;% et(seq(0, 24, length.out=100)) rxSolve(m1, ev) %&gt;% plot(depot,C2, eff) 7.7 Classic rxode2 events Originally RxODE supported compound event IDs; rxode2 still supports these parameters, but it is often more useful to use the the normal NONMEM dataset standard that is used by many modeling tools like NONMEM, Monolix and nlmixr, described in the rxode2 types article. Classically, RxODE supported event coding in a single event id evid described in the following table. 100+ cmt Infusion/Event Flag &lt;99 Cmt SS flag &amp; Turning off Compartment 100+ cmt 0 = bolus dose &lt; 99 cmt 01 = dose 1 = infusion (rate) 08 = Turn off Steady state infusion with lag time 2 = infusion (dur) 09 = Steady state 1 at dose time with alag (SS=1) 6 = turn off modeled duration 10 = Steady state 1 (equivalent to SS=1) without alag() 7 = turn off modeled rate 09 = Steady state 1/2 at dose+ alag() 8 = turn on modeled duration 19 = Steady state 2 at dose time with alag (SS=2) 9 = turn on modeled rate 20 = Steady state 2 (equivalent to SS=2) 4 = replace event 30 = Turn off a compartment (equivalent to -CMT w/EVID=2) 5 = multiply event 40 = Steady state constant infusion 50 = Phantom event, used for transit compartments doses The classic EVID concatenate the numbers in the above table, so an infusion would to compartment 1 would be 10101 and an infusion to compartment 199 would be 119901. EVID = 0 (observations), EVID=2 (other type event) and EVID=3 are all supported. Internally an EVID=9 is a non-observation event and makes sure the system is initialized to zero; EVID=9 should not be manually set. EVID 10-99 represents modeled time interventions, similar to NONMEM’s MTIME. This along with amount (amt) and time columns specify the events in the ODE system. For infusions specified with EVIDs &gt; 100 the amt column represents the rate value. For Infusion flags 1 and 2 +amt turn on the infusion to a specific compartment -amt turn off the infusion to a specific compartment. To specify a dose/duration you place the dosing records at the time the duration starts or stops. For modeled rate/duration infusion flags the on infusion flag must be followed by an off infusion record. These number are concatenated together to form a full RxODE event ID, as shown in the following examples: 7.7.1 Bolus Dose Examples A 100 bolus dose to compartment #1 at time 0 time evid amt 0 101 100 0.5 0 0 1 0 0 A 100 bolus dose to compartment #99 at time 0 time evid amt 0 9901 100 0.5 0 0 1 0 0 A 100 bolus dose to compartment #199 at time 0 time evid amt 0 109901 100 0.5 0 0 1 0 0 7.7.2 Infusion Event Examples Bolus infusion with rate 50 to compartment 1 for 1.5 hr, (modeled bioavailability changes duration of infusion) time evid amt 0 10101 50 0.5 0 0 1 0 0 1.5 10101 -50 Bolus infusion with rate 50 to compartment 1 for 1.5 hr (modeled bioavailability changes rate of infusion) time evid amt 0 20101 50 0.5 0 0 1 0 0 1.5 20101 -50 Modeled rate with amount of 50 time evid amt 0 90101 50 0 70101 50 0.5 0 0 1 0 0 Modeled duration with amount of 50 time evid amt 0 80101 50 0 60101 50 0.5 0 0 1 0 0 7.7.3 Steady State for classic RxODE EVID example Steady state dose to cmt 1 time evid amt ii 0 110 50 24 Steady State with super-positioning principle for am 50 and pm 100 dose time evid amt ii 0 110 50 24 12 120 100 24 7.7.4 Steady state with lagged dose for classic RxODE evid Steady state with lagged dose for a bolus dose: time | evid | amt | ii | 0 | 109 | 100 | 24 | 0 | 101 | 100 | 0 | The event 109 calculates the trough amount after the steady state has passed by (ii-lag_time) while event 101 applies the next steady state dose. Steady state (=2) with a lagged bolus dose time evid amt ii 0 109 50 24 0 101 50 12 119 100 24 12 101 100 Steady state infusion with lag time time | evid | amt | ii | 0 | 10109 | 5 | 24 | 0 | 10108 | -5 | 24 | 0 | 10101 | 5 | | 20 | 10101 | -5 | | As in the case of the bolus, the 10109 event calculates the trough concentration with ii=24, which may (or may not) still have an infusion running. If the infusion is running the 10108 event will turn off that infusion at the appropriate time. If the infusion has been completed, then the 10108 event is ignored. The next 2 events 10101 represent the event times (assuming no bioavailability has been applied). 7.7.5 Turning off a compartment with classic RxODE EVID Turn off the first compartment at time 12 time evid amt 0 110 50 Event coding in rxode2 is encoded in a single event number evid. For compartments under 100, this is coded as: This event is 0 for observation events. For a specified compartment a bolus dose is defined as: 100*(Compartment Number) + 1 The dose is then captured in the amt For IV bolus doses the event is defined as: 10000 + 100*(Compartment Number) + 1 The infusion rate is captured in the amt column The infusion is turned off by subtracting amt with the same evid at the stop of the infusion. For compartments greater or equal to 100, the 100s place and above digits are transferred to the 100,000th place digit. For doses to the 99th compartment the evid for a bolus dose would be 9901 and the evid for an infusion would be 19901. For a bolus dose to the 199th compartment the evid for the bolus dose would be 109901. An infusion dosing record for the 199th compartment would be 119901. 7.8 Datasets for rxode2 &amp; nlmixr Data for input into nlmixr is the same type of data input for rxode2, and it is similar to data for NONMEM (most NONMEM-ready datasets can be used directly in nlmixr). 7.9 Columns Described by Type of Use 7.9.1 Subject Identification Columns The subject identification column separates subjects for identification of random effects. ID: A subject identifier that may be an integer, character, or factor. 7.9.2 Observation Columns Observation columns are used to indicate the dependent variable and how to use or measure it. DV: A numeric column with the measurement CENS: A numeric column for indication of censoring, such as below the limit of quantification for an assay. LIMIT: A numeric column for helping indicate the type of censoring, such as below the limit of quantification for an assay. MDV: An indicator for missing DV values CMT: The name or number of the compartment DVID: The dependent variable identifier EVID The event identifier 7.9.3 Dosing Columns AMT: The amount of the dose CMT: The name or number of the compartment EVID: The event identifier ADDL: The number of additional doses RATE or DUR: The rate or duration of a dose 7.9.4 Covariate Columns 7.10 Details for Specific Dataset Columns The details below are sorted alphabetically by column name. For grouping by use, see the documentation above. 7.10.1 AMT Column The AMT column defines the amount of a dose. For observation rows, it should be 0 or NA. For dosing rows, it is the amount of the dose administered to the CMT. If the dose has a zero-order rate (such as a constant infusion), the infusion may be setup using the RATE or DUR column. 7.10.2 CENS/LIMIT Columns The CENS column is an indicator column indicating if censoring occurred. For pharmacokinetic modeling, censoring is typically when a sample is below the limit of quantification. Internally rxode2 saves these values so that nlmixr can use them in likelihood calculations. CENS = 0 indicates that the value in DV is measured without censoring. CENS = 1 indicates that a value is left censored (or below the limit of quantitation) and that the value in DV is censoring/quantitation limit. CENS = -1 indicates that a value is right censored (or above limit of quantitation) and that the value in DV is censoring/quantitation limit. The LIMIT is additional information about how censoring is handled with nlmixr and is stored in rxode2’s data structure as well. When a value is left censored, like below a limit of 1 you may also believe that the value is above a certain threshold, like zero. In this case, a limit of 0 indicates that the censored value is between 0 and 1. In short when: CENS = 0 a LIMIT is ignored because the observation is not censored CENS = 1 the value is censored between (LIMIT, DV) CENS = -1 the value is censored between (DV, LIMIT) 7.10.3 CMT Column The CMT column indicates the compartment where an event occurs. When given as a character string or factor (the preferred method), it is matched by name in the model. When given as an integer, it is matched by the order that compartments appear in the model. 7.10.4 DUR Column The DUR column defines the duration of an infusion. It is used to set the duration of a zero-order rate of infusion. 7.10.5 DV Column The DV column indicates the current measurement in the current compartment (see CMT) with the current measurement identifier (see DVID) which may be missing (see MDV) or censored (see CENS). 7.10.6 DVID Column TODO 7.10.7 EVID Column The EVID column is the event identifier for a row of data. For observation records, it will be 0. For normal dosing records, it will be 1. Many more EVID values are detailed in the rxode2 Event Types and Classic rxode2 Events vignettes. 7.10.8 ID Column The ID column is a subject identifier. This column is used to separate one individual (usually a single person or animal) from another. In the model, the ID column is used to separate individuals. The numerical integrator re-initializes with each new individual, and new values for all random effects are selected. 7.10.9 RATE Column TODO "],["et.html", "Chapter 8 Easily creating rxode2 events 8.1 Adding doses to the event table 8.2 Adding sampling to an event table 8.3 Expand the event table to a multi-subject event table. 8.4 Add doses and samples within a sampling window 8.5 Combining event tables 8.6 Sequencing event tables 8.7 Repeating event tables 8.8 Combining event tables with rbind 8.9 Event tables in Rstudio Notebooks", " Chapter 8 Easily creating rxode2 events An event table in rxode2 is a specialized data frame that acts as a container for all of rxode2’s events and observation times. To create an rxode2 event table you may use the code eventTable(), et(), or even create your own data frame with the right event information contained in it. This is closely related to the types of events that rxode2 supports. library(rxode2) library(units) #&gt; udunits database from /usr/share/xml/udunits/udunits2.xml (ev &lt;- et()) #&gt; ── EventTable with 0 records ── #&gt; 0 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 0 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) or (ev &lt;- et()) #&gt; ── EventTable with 0 records ── #&gt; 0 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 0 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) With this event table you can add sampling/observations or doses by piping or direct access. This is a short table of the two main functions to create dosing add.dosing() et() Description dose amt Dose/Rate/Duration amount nbr.doses addl Additional doses or number of doses dosing.interval ii Dosing Interval dosing.to cmt Dosing Compartment rate rate Infusion rate start.time time Dosing start time dur Infusion Duration Sampling times can be added with add.sampling( sampling times ) or et( sampling times ). Dosing intervals and sampling windows are also supported. With most of the documentation we will be using the et() syntax, though both are supported. For these models, we can illustrate by using the model shared in the rxode2 tutorial: ## Model from rxode2 tutorial m1 &lt;-function() { ini({ KA &lt;- 2.94E-01 CL &lt;- 1.86E+01 V2 &lt;- 4.02E+01 Q &lt;- 1.05E+01 V3 &lt;- 2.97E+02 Kin &lt;- 1 Kout &lt;- 1 EC50 &lt;- 200 ## Added modeled bioavaiblity, duration and rate fdepot &lt;- 1 durDepot &lt;- 8 rateDepot &lt;- 1250 }) model({ C2 &lt;- centr/V2 C3 &lt;- peri/V3 d/dt(depot) &lt;- -KA*depot f(depot) &lt;- fdepot dur(depot) &lt;- durDepot rate(depot) &lt;- rateDepot d/dt(centr) &lt;- KA*depot - CL*C2 - Q*C2 + Q*C3 d/dt(peri) &lt;- Q*C2 - Q*C3 d/dt(eff) &lt;- Kin - Kout*(1-C2/(EC50+C2))*eff; eff(0) &lt;- 1 }) } 8.1 Adding doses to the event table Once created you can add dosing to the event table by the add.dosing(), and et() functions. Using the add.dosing() function you have: argument meaning dose dose amount nbr.doses Number of doses; Should be at least 1. dosing.interval Dosing interval; By default this is 24. dosing.to Compartment where dose is administered. rate Infusion rate start.time The start time of the dose ev &lt;- eventTable(amount.units=&quot;mg&quot;, time.units=&quot;hr&quot;) ## The methods ar attached to the event table, so you can use ## them directly ev$add.dosing(dose=10000, nbr.doses = 3)# loading doses ## Starts at time 0; Default dosing interval is 24 ## You can also pipe the event tables to these methods. ev &lt;- ev %&gt;% add.dosing(dose=5000, nbr.doses=14, dosing.interval=12)# maintenance ev #&gt; ── EventTable with 2 records ── #&gt; 2 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 0 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 2 × 5 #&gt; time amt ii addl evid #&gt; [h] [mg] [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 10000 24 2 1:Dose (Add) #&gt; 2 0 5000 12 13 1:Dose (Add) Notice that the units were specified in the table. When specified, the units use the units package to keep track of the units and convert them if needed. Additionally, ggforce uses them to label the ggplot axes. The set_units and drop_units are useful to set and drop the rxode2 event table units. In this example, you can see the time axes is labeled: rxSolve(m1, ev) %&gt;% plot(C2) If you are more familiar with the NONMEM/rxode2 event records, you can also specify dosing using et with the dose elements directly: ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, until = set_units(3, days), ii=12) # loading doses ev #&gt; ── EventTable with 1 records ── #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 0 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 1 × 5 #&gt; time amt ii addl evid #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 10000 12 6 1:Dose (Add) Which gives: rxSolve(m1, ev) %&gt;% plot(C2) This shows how easy creating event tables can be. 8.2 Adding sampling to an event table If you notice in the above examples, rxode2 generated some default sampling times since there was not any sampling times. If you wish more control over the sampling time, you should add the samples to the rxode2 event table by add.sampling or et ev &lt;- eventTable(amount.units=&quot;mg&quot;, time.units=&quot;hr&quot;) ## The methods ar attached to the event table, so you can use them ## directly ev$add.dosing(dose=10000, nbr.doses = 3)# loading doses ev$add.sampling(seq(0,24,by=4)) ev #&gt; ── EventTable with 8 records ── #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 7 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 8 × 5 #&gt; time amt ii addl evid #&gt; [h] [mg] [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 NA NA NA 0:Observation #&gt; 2 0 10000 24 2 1:Dose (Add) #&gt; 3 4 NA NA NA 0:Observation #&gt; 4 8 NA NA NA 0:Observation #&gt; 5 12 NA NA NA 0:Observation #&gt; 6 16 NA NA NA 0:Observation #&gt; 7 20 NA NA NA 0:Observation #&gt; 8 24 NA NA NA 0:Observation Which gives: solve(m1, ev) %&gt;% plot(C2) Or if you use et you can simply add them in a similar way to add.sampling: ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, until = set_units(3, days), ii=12) %&gt;% # loading doses et(seq(0,24,by=4)) ev #&gt; ── EventTable with 8 records ── #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 7 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 8 × 5 #&gt; time amt ii addl evid #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 NA NA NA 0:Observation #&gt; 2 0 10000 12 6 1:Dose (Add) #&gt; 3 4 NA NA NA 0:Observation #&gt; 4 8 NA NA NA 0:Observation #&gt; 5 12 NA NA NA 0:Observation #&gt; 6 16 NA NA NA 0:Observation #&gt; 7 20 NA NA NA 0:Observation #&gt; 8 24 NA NA NA 0:Observation which gives the following rxode2 solve: solve(m1, ev) %&gt;% plot(C2) Note the jagged nature of these plots since there was only a few sample times. 8.3 Expand the event table to a multi-subject event table. The only thing that is needed to expand an event table is a list of IDs that you want to expand; ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, until = set_units(3, days), ii=12) %&gt;% # loading doses et(seq(0,48,length.out=200)) %&gt;% et(id=1:4) ev #&gt; ── EventTable with 804 records ── #&gt; 4 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 800 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 804 × 6 #&gt; id time amt ii addl evid #&gt; &lt;int&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 1 0 NA NA NA 0:Observation #&gt; 2 1 0 10000 12 6 1:Dose (Add) #&gt; 3 1 0.241 NA NA NA 0:Observation #&gt; 4 1 0.482 NA NA NA 0:Observation #&gt; 5 1 0.724 NA NA NA 0:Observation #&gt; 6 1 0.965 NA NA NA 0:Observation #&gt; 7 1 1.21 NA NA NA 0:Observation #&gt; 8 1 1.45 NA NA NA 0:Observation #&gt; 9 1 1.69 NA NA NA 0:Observation #&gt; 10 1 1.93 NA NA NA 0:Observation #&gt; # ℹ 794 more rows You can see in the following simulation there are 4 individuals that are solved for: set.seed(42) rxSetSeed(42) solve(m1, ev, params=data.frame(KA=0.294*exp(rnorm(4)), CL=18.6*exp(rnorm(4)))) %&gt;% plot(C2) 8.4 Add doses and samples within a sampling window In addition to adding fixed doses and fixed sampling times, you can have windows where you sample and draw doses from. For dosing windows you specify the time as an ordered numerical vector with the lowest dosing time and the highest dosing time inside a list. In this example, you start with a dosing time with a 6 hour dosing window: set.seed(42) rxSetSeed(42) ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(time=list(c(0,6)), amt=10000, until = set_units(2, days), ii=12) %&gt;% # loading doses et(id=1:4) ev #&gt; ── EventTable with 16 records ── #&gt; 16 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 0 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; ── First part of x: ── #&gt; # A tibble: 16 × 6 #&gt; id low time high amt evid #&gt; &lt;int&gt; [h] [h] [h] &lt;dbl&gt; &lt;evid&gt; #&gt; 1 1 0 5.49 6 10000 1:Dose (Add) #&gt; 2 1 12 17.0 18 10000 1:Dose (Add) #&gt; 3 1 24 25.7 30 10000 1:Dose (Add) #&gt; 4 1 36 41.6 42 10000 1:Dose (Add) #&gt; 5 2 0 4.31 6 10000 1:Dose (Add) #&gt; 6 2 12 14.7 18 10000 1:Dose (Add) #&gt; 7 2 24 28.2 30 10000 1:Dose (Add) #&gt; 8 2 36 39.9 42 10000 1:Dose (Add) #&gt; 9 3 0 0.808 6 10000 1:Dose (Add) #&gt; 10 3 12 16.4 18 10000 1:Dose (Add) #&gt; 11 3 24 27.1 30 10000 1:Dose (Add) #&gt; 12 3 36 39.9 42 10000 1:Dose (Add) #&gt; 13 4 0 4.98 6 10000 1:Dose (Add) #&gt; 14 4 12 13.7 18 10000 1:Dose (Add) #&gt; 15 4 24 29.6 30 10000 1:Dose (Add) #&gt; 16 4 36 41.5 42 10000 1:Dose (Add) You can clearly see different dosing times in the following simulation: ev &lt;- ev %&gt;% et(seq(0,48,length.out=200)) solve(m1, ev, params=data.frame(KA=0.294*exp(rnorm(4)), CL=18.6*exp(rnorm(4)))) %&gt;% plot(C2) Of course in reality the dosing interval may only be 2 hours: set.seed(42) rxSetSeed(42) ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(time=list(c(0,2)), amt=10000, until = set_units(2, days), ii=12) %&gt;% # loading doses et(id=1:4) %&gt;% et(seq(0,48,length.out=200)) solve(m1, ev, params=data.frame(KA=0.294*exp(rnorm(4)), CL=18.6*exp(rnorm(4)))) %&gt;% plot(C2) The same sort of thing can be specified with sampling times. To specify the sampling times in terms of a sampling window, you can create a list of the sampling times. Each sampling time will be a two element ordered numeric vector. rxSetSeed(42) set.seed(42) ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(time=list(c(0,2)), amt=10000, until = set_units(2, days), ii=12) %&gt;% # loading doses et(id=1:4) ## Create 20 samples in the first 24 hours and 20 samples in the ## second 24 hours samples &lt;- c(lapply(1:20, function(...){c(0,24)}), lapply(1:20, function(...){c(20,48)})) ## Add the random collection to the event table ev &lt;- ev %&gt;% et(samples) library(ggplot2) solve(m1, ev, params=data.frame(KA=0.294*exp(rnorm(4)), CL=18.6*exp(rnorm(4)))) %&gt;% plot(C2) + geom_point() This shows the flexibility in dosing and sampling that the rxode2 event tables allow. 8.5 Combining event tables Since you can create dosing records and sampling records, you can create any complex dosing regimen you wish. In addition, rxode2 allows you to combine event tables by c, seq, rep, and rbind. 8.6 Sequencing event tables One way to combine event table is to sequence them by c, seq or etSeq. This takes the two dosing groups and adds at least one inter-dose interval between them: ## bid for 5 days bid &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000,ii=12,until=set_units(5, &quot;days&quot;)) ## qd for 5 days qd &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=20000,ii=24,until=set_units(5, &quot;days&quot;)) ## bid for 5 days followed by qd for 5 days et &lt;- seq(bid,qd) %&gt;% et(seq(0,11*24,length.out=100)); rxSolve(m1, et) %&gt;% plot(C2) When sequencing events, you can also separate this sequence by a period of time; For example if you wanted to separate this by a week, you could easily do that with the following sequence of event tables: ## bid for 5 days followed by qd for 5 days et &lt;- seq(bid,set_units(1, &quot;week&quot;), qd) %&gt;% et(seq(0,18*24,length.out=100)); rxSolve(m1, et) %&gt;% plot(C2) Note that in this example the time between the bid and the qd event tables is exactly one week, not 1 week plus 24 hours because of the inter-dose interval. If you want that behavior, you can sequence it using the wait=\"+ii\". ## bid for 5 days followed by qd for 5 days et &lt;- seq(bid,set_units(1, &quot;week&quot;), qd,wait=&quot;+ii&quot;) %&gt;% et(seq(0,18*24,length.out=100)); rxSolve(m1, et) %&gt;% plot(C2) Also note, that rxode2 assumes that the dosing is what you want to space the event tables by, and clears out any sampling records when you combine the event tables. If that is not true, you can also use the option samples=\"use\" 8.7 Repeating event tables You can have an event table that you can repeat with etRep or rep. For example 4 rounds of 2 weeks on QD therapy and 1 week off of therapy can be simply specified: qd &lt;-et(timeUnits = &quot;hr&quot;) %&gt;% et(amt=10000, ii=24, until=set_units(2, &quot;weeks&quot;), cmt=&quot;depot&quot;) et &lt;- rep(qd, times=4, wait=set_units(1,&quot;weeks&quot;)) %&gt;% add.sampling(set_units(seq(0, 12.5,by=0.005),weeks)) rxSolve(m1, et) %&gt;% plot(C2) This is a simplified way to use a sequence of event tables. Therefore, many of the same options still apply; That is samples are cleared unless you use samples=\"use\", and the time between event tables is at least the inter-dose interval. You can adjust the timing by the wait option. 8.8 Combining event tables with rbind You may combine event tables with rbind. This does not consider the event times when combining the event tables, but keeps them the same times. If you space the event tables by a waiting period, it also does not consider the inter-dose interval. Using the previous seq you can clearly see the difference. Here was the sequence: ## bid for 5 days bid &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000,ii=12,until=set_units(5, &quot;days&quot;)) ## qd for 5 days qd &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=20000,ii=24,until=set_units(5, &quot;days&quot;)) et &lt;- seq(bid,qd) %&gt;% et(seq(0,18*24,length.out=500)); rxSolve(m1, et) %&gt;% plot(C2) But if you bind them together with rbind ## bid for 5 days et &lt;- rbind(bid,qd) %&gt;% et(seq(0,18*24,length.out=500)); rxSolve(m1, et) %&gt;% plot(C2) Still the waiting period applies (but does not consider the inter-dose interval) et &lt;- rbind(bid,wait=set_units(10,days),qd) %&gt;% et(seq(0,18*24,length.out=500)); rxSolve(m1, et) %&gt;% plot(C2) You can also bind the tables together and make each ID in the event table unique; This can be good to combine cohorts with different expected dosing and sampling times. This requires the id=\"unique\" option; Using the first example shows how this is different in this case: ## bid for 5 days et &lt;- etRbind(bid,qd, id=&quot;unique&quot;) %&gt;% et(seq(0,150,length.out=500)); library(ggplot2) rxSolve(m1, et) %&gt;% plot(C2) + facet_wrap( ~ id) 8.9 Event tables in Rstudio Notebooks In addition to the output in the console which has been shown in the above examples, Rstudio notebook output is different and can be seen in the following screenshots; The first screenshot shows how the event table looks after evaluating it in the Rstduio notebook This is a simple dataframe that allows you to page through the contents. If you click on the first box in the Rstudio notebook output, it will have the notes about the event table: ## Expanding events Event tables can be expanded so they contain an addl data item, like the following example: ev &lt;- et() %&gt;% et(dose=50, ii=8, until=48) ev #&gt; ── EventTable with 1 records ── #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 0 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 1 × 5 #&gt; time amt ii addl evid #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;evid&gt; #&gt; 1 0 50 8 6 1:Dose (Add) You can expand the events so they do not have the addl items by $expand() or etExpand(ev): The first, etExpand(ev) expands the event table without modifying the original data frame: etExpand(ev) #&gt; ── EventTable with 7 records ── #&gt; 7 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 0 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; ── First part of x: ── #&gt; # A tibble: 7 × 4 #&gt; time amt ii evid #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;evid&gt; #&gt; 1 0 50 0 1:Dose (Add) #&gt; 2 8 50 0 1:Dose (Add) #&gt; 3 16 50 0 1:Dose (Add) #&gt; 4 24 50 0 1:Dose (Add) #&gt; 5 32 50 0 1:Dose (Add) #&gt; 6 40 50 0 1:Dose (Add) #&gt; 7 48 50 0 1:Dose (Add) You can see the addl events were expanded, however the original data frame remained intact: print(ev) #&gt; ── EventTable with 1 records ── #&gt; 1 dosing records (see $get.dosing(); add with add.dosing or #&gt; et) #&gt; 0 observation times (see $get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with $expand(); or #&gt; etExpand() #&gt; ── First part of : ── #&gt; # A tibble: 1 × 5 #&gt; time amt ii addl evid #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;evid&gt; #&gt; 1 0 50 8 6 1:Dose (Add) If you use ev$expand() it will modify the ev object. This is similar to an object-oriented method: ev$expand() ev #&gt; ── EventTable with 7 records ── #&gt; 7 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 0 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; ── First part of x: ── #&gt; # A tibble: 7 × 4 #&gt; time amt ii evid #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;evid&gt; #&gt; 1 0 50 0 1:Dose (Add) #&gt; 2 8 50 0 1:Dose (Add) #&gt; 3 16 50 0 1:Dose (Add) #&gt; 4 24 50 0 1:Dose (Add) #&gt; 5 32 50 0 1:Dose (Add) #&gt; 6 40 50 0 1:Dose (Add) #&gt; 7 48 50 0 1:Dose (Add) "],["solve.html", "Chapter 9 Solving and solving options 9.1 General Solving Options 9.2 Inductive Linerization Options 9.3 Steady State Solving Options 9.4 rxode2 numeric stability options 9.5 Linear compartment model sensitivity options 9.6 Covariate Solving Options 9.7 Simulation options 9.8 rxode2 output options 9.9 Internal rxode2 options 9.10 Parallel/Threaded Solve", " Chapter 9 Solving and solving options In general, ODEs are solved using a combination of: A compiled model specification from rxode2(), specified with object= Input parameters, specified with params= (and could be blank) Input data or event table, specified with events= Initial conditions, specified by inits= (and possibly in the model itself by state(0)=) The solving options are given in the sections below: 9.1 General Solving Options 9.1.1 object object is a either a rxode2 family of objects, or a file-name with a rxode2 model specification, or a string with a rxode2 model specification. 9.1.2 params params a numeric named vector with values for every parameter in the ODE system; the names must correspond to the parameter identifiers used in the ODE specification; 9.1.3 events events an eventTable object describing the input (e.g., doses) to the dynamic system and observation sampling time points (see [eventTable()]); 9.1.4 inits inits a vector of initial values of the state variables (e.g., amounts in each compartment), and the order in this vector must be the same as the state variables (e.g., PK/PD compartments); 9.1.5 sigdig sigdig Specifies the “significant digits” that the ode solving requests. When specified this controls the relative and absolute tolerances of the ODE solvers. By default the tolerance is 0.5*10^(-sigdig-2) for regular ODEs. For the sensitivity equations the default is 0.5*10\\^(-sigdig-1.5) (sensitivity changes only applicable for liblsoda). This also ## lsoda/dop solving options controls the atol/rtol of the steady state solutions. The ssAtol/ssRtol is 0.5*10\\^(-sigdig) and for the sensitivities 0.5*10\\^(-sigdig+0.625). By default this is unspecified (NULL) and uses the standard atol/rtol. 9.1.6 atol atol a numeric absolute tolerance (1e-8 by default) used by the ODE solver to determine if a good solution has been achieved; This is also used in the solved linear model to check if prior doses do not add anything to the solution. 9.1.7 rtol rtol a numeric relative tolerance (1e-6 by default) used by the ODE solver to determine if a good solution has been achieved. This is also used in the solved linear model to check if prior doses do not add anything to the solution. 9.1.8 atolSens atolSens Sensitivity atol, can be different than atol with liblsoda. This allows a less accurate solve for gradients (if desired) 9.1.9 rtolSens rtolSens Sensitivity rtol, can be different than rtol with liblsoda. This allows a less accurate solve for gradients (if desired) 9.1.10 maxsteps maxsteps maximum number of (internally defined) steps allowed during one call to the solver. (5000 by default) 9.1.11 hmin hmin The minimum absolute step size allowed. The default value is 0. 9.1.12 hmax hmax The maximum absolute step size allowed. When hmax=NA (default), uses the average difference + hmaxSd*sd in times and sampling events. The hmaxSd is a user specified parameter and which defaults to zero. When hmax=NULL rxode2 uses the maximum difference in times in your sampling and events. The value 0 is equivalent to infinite maximum absolute step size. 9.1.13 hmaxSd hmaxSd The number of standard deviations of the time difference to add to hmax. The default is 0 9.1.14 hini hini The step size to be attempted on the first step. The default value is determined by the solver (when hini = 0) 9.1.15 maxordn maxordn The maximum order to be allowed for the nonstiff (Adams) method. The default is 12. It can be between 1 and 12. 9.1.16 maxords maxords The maximum order to be allowed for the stiff (BDF) method. The default value is 5. This can be between 1 and 5. 9.1.17 mxhnil mxhnil maximum number of messages printed (per problem) warning that T + H = T on a step (H = step size). This must be positive to result in a non-default value. The default value is 0 (or infinite). 9.1.18 hmxi hmxi inverse of the maximum absolute value of H to are used. hmxi = 0.0 is allowed and corresponds to an infinite hmax1 (default).hminandhmximay be changed at any time, but will not take effect until the next change ofHis considered. This option is only considered withmethod=“liblsoda”`. 9.1.19 istateReset istateReset When TRUE, reset the ISTATE variable to 1 for lsoda and liblsoda with doses, like deSolve; When FALSE, do not reset the ISTATE variable with doses. 9.2 Inductive Linerization Options 9.2.1 indLinMatExpType indLinMatExpType This is them matrix exponential type that is use for rxode2. Currently the following are supported: Al-Mohy Uses the exponential matrix method of Al-Mohy Higham (2009) arma Use the exponential matrix from RcppArmadillo expokit Use the exponential matrix from Roger B. Sidje (1998) 9.2.2 indLinMatExpOrder indLinMatExpOrder an integer, the order of approximation to be used, for the Al-Mohy and expokit values. The best value for this depends on machine precision (and slightly on the matrix). We use 6 as a default. 9.2.3 indLinPhiTol indLinPhiTol the requested accuracy tolerance on exponential matrix. 9.2.4 indLinPhiM indLinPhiM the maximum size for the Krylov basis 9.3 Steady State Solving Options 9.3.1 minSS minSS Minimum number of iterations for a steady-state dose 9.3.2 maxSS maxSS Maximum number of iterations for a steady-state dose 9.3.3 strictSS strictSS Boolean indicating if a strict steady-state is required. If a strict steady-state is (TRUE) required then at least minSS doses are administered and the total number of steady states doses will continue until maxSS is reached, or atol and rtol for every compartment have been reached. However, if ODE solving problems occur after the minSS has been reached the whole subject is considered an invalid solve. If strictSS is FALSE then as long as minSS has been reached the last good solve before ODE solving problems occur is considered the steady state, even though either atol, rtol or maxSS have not been achieved. 9.3.4 infSSstep infSSstep Step size for determining if a constant infusion has reached steady state. By default this is large value, 12. 9.3.5 ssAtol ssAtol Steady state atol convergence factor. Can be a vector based on each state. 9.3.6 ssRtol ssRtol Steady state rtol convergence factor. Can be a vector based on each state. 9.3.7 ssAtolSens ssAtolSens Sensitivity absolute tolerance (atol) for calculating if steady state has been achieved for sensitivity compartments. 9.3.8 ssRtolSens ssRtolSens Sensitivity relative tolerance (rtol) for calculating if steady state has been achieved for sensitivity compartments. 9.4 rxode2 numeric stability options 9.4.1 maxAtolRtolFactor maxAtolRtolFactor The maximum atol/rtol that FOCEi and other routines may adjust to. By default 0.1 9.4.2 stateTrim stateTrim When amounts/concentrations in one of the states are above this value, trim them to be this value. By default Inf. Also trims to -stateTrim for large negative amounts/concentrations. If you want to trim between a range say c(0, 2000000) you may specify 2 values with a lower and upper range to make sure all state values are in the reasonable range. 9.4.3 safeZero safeZero Use safe zero divide and log routines. By default this is turned on but you may turn it off if you wish. 9.4.4 sumType sumType Sum type to use for sum() in rxode2 code blocks. pairwise uses the pairwise sum (fast, default) fsum uses the PreciseSum package’s fsum function (most accurate) kahan uses Kahan correction neumaier uses Neumaier correction c uses no correction: default/native summing 9.4.5 prodType prodType Product to use for prod() in rxode2 blocks long double converts to long double, performs the multiplication and then converts back. double uses the standard double scale for multiplication. 9.4.6 maxwhile maxwhile represents the maximum times a while loop is evaluated before exiting. By default this is 100000 9.5 Linear compartment model sensitivity options 9.5.1 sensType sensType Sensitivity type for linCmt() model: advan Use the direct advan solutions autodiff Use the autodiff advan solutions forward Use forward difference solutions central Use central differences 9.5.2 linDiff linDiff This gives the linear difference amount for all the types of linear compartment model parameters where sensitivities are not calculated. The named components of this numeric vector are: \"lag\" Central compartment lag \"f\" Central compartment bioavailability \"rate\" Central compartment modeled rate \"dur\" Central compartment modeled duration \"lag2\" Depot compartment lag \"f2\" Depot compartment bioavailability \"rate2\" Depot compartment modeled rate \"dur2\" Depot compartment modeled duration 9.5.3 linDiffCentral linDiffCentral This gives the which parameters use central differences for the linear compartment model parameters. The are the same components as linDiff 9.6 Covariate Solving Options 9.6.1 iCov iCov A data frame of individual non-time varying covariates to combine with the events dataset by merge. 9.6.2 covsInterpolation covsInterpolation specifies the interpolation method for time-varying covariates. When solving ODEs it often samples times outside the sampling time specified in events. When this happens, the time varying covariates are interpolated. Currently this can be: \"linear\" interpolation, which interpolates the covariate by solving the line between the observed covariates and extrapolating the new covariate value. \"constant\" – Last observation carried forward (the default). \"NOCB\" – Next Observation Carried Backward. This is the same method that NONMEM uses. \"midpoint\" Last observation carried forward to midpoint; Next observation carried backward to midpoint. 9.6.3 addCov addCov A boolean indicating if covariates should be added to the output matrix or data frame. By default this is disabled. 9.7 Simulation options 9.7.1 seed seed an object specifying if and how the random number generator should be initialized 9.7.2 nsim nsim represents the number of simulations. For rxode2, if you supply single subject event tables (created with [eventTable()]) 9.7.3 thetaMat thetaMat Named theta matrix. 9.7.4 thetaLower thetaLower Lower bounds for simulated population parameter variability (by default -Inf) 9.7.5 thetaUpper thetaUpper Upper bounds for simulated population unexplained variability (by default Inf) 9.7.6 thetaDf thetaDf The degrees of freedom of a t-distribution for simulation. By default this is NULL which is equivalent to Inf degrees, or to simulate from a normal distribution instead of a t-distribution. 9.7.7 thetaIsChol thetaIsChol Indicates if the theta supplied is a Cholesky decomposed matrix instead of the traditional symmetric matrix. 9.7.8 nStud nStud Number virtual studies to characterize uncertainty in estimated parameters. 9.7.9 omega omega Estimate of Covariance matrix. When omega is a list, assume it is a block matrix and convert it to a full matrix for simulations. When omega is NA and you are using it with a rxode2 ui model, the between subject variability described by the omega matrix are set to zero. 9.7.10 omegaIsChol omegaIsChol Indicates if the omega supplied is a Cholesky decomposed matrix instead of the traditional symmetric matrix. 9.7.11 omegaSeparation omegaSeparation Omega separation strategy Tells the type of separation strategy when simulating covariance with parameter uncertainty with standard deviations modeled in the thetaMat matrix. \"lkj\" simulates the correlation matrix from the rLKJ1 matrix with the distribution parameter eta equal to the degrees of freedom nu by (nu-1)/2 \"separation\" simulates from the identity inverse Wishart covariance matrix with nu degrees of freedom. This is then converted to a covariance matrix and augmented with the modeled standard deviations. While computationally more complex than the \"lkj\" prior, it performs better when the covariance matrix size is greater or equal to 10 \"auto\" chooses \"lkj\" when the dimension of the matrix is less than 10 and \"separation\" when greater than equal to 10. 9.7.12 omegaXform omegaXform When taking omega values from the thetaMat simulations (using the separation strategy for covariance simulation), how should the thetaMat values be turned int standard deviation values: identity This is when standard deviation values are directly modeled by the params and thetaMat matrix variance This is when the params and thetaMat simulates the variance that are directly modeled by the thetaMat matrix log This is when the params and thetaMat simulates log(sd) nlmixrSqrt This is when the params and thetaMat simulates the inverse cholesky decomposed matrix with the x\\^2 modeled along the diagonal. This only works with a diagonal matrix. nlmixrLog This is when the params and thetaMat simulates the inverse cholesky decomposed matrix with the exp(x\\^2) along the diagonal. This only works with a diagonal matrix. nlmixrIdentity This is when the params and thetaMat simulates the inverse cholesky decomposed matrix. This only works with a diagonal matrix. 9.7.13 omegaLower omegaLower Lower bounds for simulated ETAs (by default -Inf) 9.7.14 omegaUpper omegaUpper Upper bounds for simulated ETAs (by default Inf) 9.7.15 omegaDf omegaDf The degrees of freedom of a t-distribution for simulation. By default this is NULL which is equivalent to Inf degrees, or to simulate from a normal distribution instead of a t-distribution. 9.7.16 nSub nSub Number between subject variabilities (ETAs) simulated for every realization of the parameters. 9.7.17 dfSub dfSub Degrees of freedom to sample the between subject variability matrix from the inverse Wishart distribution (scaled) or scaled inverse chi squared distribution. 9.7.18 sigma sigma Named sigma covariance or Cholesky decomposition of a covariance matrix. The names of the columns indicate parameters that are simulated. These are simulated for every observation in the solved system. When sigma is NA and you are using it with a rxode2 ui model, the unexplained variability described by the sigma matrix are set to zero. 9.7.19 sigmaLower sigmaLower Lower bounds for simulated unexplained variability (by default -Inf) 9.7.20 sigmaUpper sigmaUpper Upper bounds for simulated unexplained variability (by default Inf) 9.7.21 sigmaXform sigmaXform When taking sigma values from the thetaMat simulations (using the separation strategy for covariance simulation), how should the thetaMat values be turned int standard deviation values: identity This is when standard deviation values are directly modeled by the params and thetaMat matrix variance This is when the params and thetaMat simulates the variance that are directly modeled by the thetaMat matrix log This is when the params and thetaMat simulates log(sd) nlmixrSqrt This is when the params and thetaMat simulates the inverse cholesky decomposed matrix with the x\\^2 modeled along the diagonal. This only works with a diagonal matrix. nlmixrLog This is when the params and thetaMat simulates the inverse cholesky decomposed matrix with the exp(x\\^2) along the diagonal. This only works with a diagonal matrix. nlmixrIdentity This is when the params and thetaMat simulates the inverse cholesky decomposed matrix. This only works with a diagonal matrix. 9.7.22 sigmaDf sigmaDf Degrees of freedom of the sigma t-distribution. By default it is equivalent to Inf, or a normal distribution. 9.7.23 sigmaIsChol sigmaIsChol Boolean indicating if the sigma is in the Cholesky decomposition instead of a symmetric covariance 9.7.24 sigmaSeparation sigmaSeparation separation strategy for sigma; Tells the type of separation strategy when simulating covariance with parameter uncertainty with standard deviations modeled in the thetaMat matrix. \"lkj\" simulates the correlation matrix from the rLKJ1 matrix with the distribution parameter eta equal to the degrees of freedom nu by (nu-1)/2 \"separation\" simulates from the identity inverse Wishart covariance matrix with nu degrees of freedom. This is then converted to a covariance matrix and augmented with the modeled standard deviations. While computationally more complex than the \"lkj\" prior, it performs better when the covariance matrix size is greater or equal to 10 \"auto\" chooses \"lkj\" when the dimension of the matrix is less than 10 and \"separation\" when greater than equal to 10. 9.7.25 dfObs dfObs Degrees of freedom to sample the unexplained variability matrix from the inverse Wishart distribution (scaled) or scaled inverse chi squared distribution. 9.7.26 resample resample A character vector of model variables to resample from the input dataset; This sampling is done with replacement. When NULL or FALSE no resampling is done. When TRUE resampling is done on all covariates in the input dataset 9.7.27 resampleID resampleID boolean representing if the resampling should be done on an individual basis TRUE (ie. a whole patient is selected) or each covariate is resampled independent of the subject identifier FALSE. When resampleID=TRUE correlations of parameters are retained, where as when resampleID=FALSE ignores patient covariate correaltions. Hence the default is resampleID=TRUE. 9.8 rxode2 output options 9.8.1 returnType returnType This tells what type of object is returned. The currently supported types are: \"rxSolve\" (default) will return a reactive data frame that can change easily change different pieces of the solve and update the data frame. This is the currently standard solving method in rxode2, is used for rxSolve(object, ...), solve(object,...), \"data.frame\" – returns a plain, non-reactive data frame; Currently very slightly faster than returnType=\"matrix\" \"matrix\" – returns a plain matrix with column names attached to the solved object. This is what is used object$run as well as object$solve \"data.table\" – returns a data.table; The data.table is created by reference (ie setDt()), which should be fast. \"tbl\" or \"tibble\" returns a tibble format. 9.8.2 addDosing addDosing Boolean indicating if the solve should add rxode2 EVID and related columns. This will also include dosing information and estimates at the doses. Be default, rxode2 only includes estimates at the observations. (default FALSE). When addDosing is NULL, only include EVID=0 on solve and exclude any model-times or EVID=2. If addDosing is NA the classic rxode2 EVID events are returned. When addDosing is TRUE add the event information in NONMEM-style format; If subsetNonmem=FALSE rxode2 will also include extra event types (EVID) for ending infusion and modeled times: EVID=-1 when the modeled rate infusions are turned off (matches rate=-1) EVID=-2 When the modeled duration infusions are turned off (matches rate=-2) EVID=-10 When the specified rate infusions are turned off (matches rate&gt;0) EVID=-20 When the specified dur infusions are turned off (matches dur&gt;0) EVID=101,102,103,... Modeled time where 101 is the first model time, 102 is the second etc. 9.8.3 keep keep Columns to keep from either the input dataset or the iCov dataset. With the iCov dataset, the column is kept once per line. For the input dataset, if any records are added to the data LOCF (Last Observation Carried forward) imputation is performed. 9.8.4 drop drop Columns to drop from the output 9.8.5 idFactor idFactor This boolean indicates if original ID values should be maintained. This changes the default sequentially ordered ID to a factor with the original ID values in the original dataset. By default this is enabled. 9.8.6 subsetNonmem subsetNonmem subset to NONMEM compatible EVIDs only. By default TRUE. 9.8.7 scale scale a numeric named vector with scaling for ode parameters of the system. The names must correspond to the parameter identifiers in the ODE specification. Each of the ODE variables will be divided by the scaling factor. For example scale=c(center=2) will divide the center ODE variable by 2. 9.8.8 amountUnits amountUnits This supplies the dose units of a data frame supplied instead of an event table. This is for importing the data as an rxode2 event table. 9.8.9 timeUnits timeUnits This supplies the time units of a data frame supplied instead of an event table. This is for importing the data as an rxode2 event table. 9.8.10 theta theta A vector of parameters that will be named THETA\\[#\\] and added to parameters 9.8.11 eta eta A vector of parameters that will be named ETA\\[#\\] and added to parameters 9.8.12 from from When there is no observations in the event table, start observations at this value. By default this is zero. 9.8.13 to to When there is no observations in the event table, end observations at this value. By default this is 24 + maximum dose time. 9.8.14 length.out length.out The number of observations to create if there isn’t any observations in the event table. By default this is 200. 9.8.15 by by When there are no observations in the event table, this is the amount to increment for the observations between from and to. 9.8.16 warnIdSort warnIdSort Warn if the ID is not present and rxode2 assumes the order of the parameters/iCov are the same as the order of the parameters in the input dataset. 9.8.17 warnDrop warnDrop Warn if column(s) were supposed to be dropped, but were not present. 9.9 Internal rxode2 options 9.9.1 nDisplayProgress nDisplayProgress An integer indicating the minimum number of c-based solves before a progress bar is shown. By default this is 10,000. 9.9.2 simVariability simVariability determines if the variability is simulated. When NA (default) this is determined by the solver. 9.9.3 … ... Other arguments including scaling factors for each compartment. This includes S# = numeric will scale a compartment # by a dividing the compartment amount by the scale factor, like NONMEM. 9.9.4 a a when using solve(), this is equivalent to the object argument. If you specify object later in the argument list it overwrites this parameter. 9.9.5 b b when using solve(), this is equivalent to the params argument. If you specify params as a named argument, this overwrites the output 9.9.6 updateObject updateObject This is an internally used flag to update the rxode2 solved object (when supplying an rxode2 solved object) as well as returning a new object. You probably should not modify it’s FALSE default unless you are willing to have unexpected results. 9.10 Parallel/Threaded Solve 9.10.1 cores cores Number of cores used in parallel ODE solving. This is equivalent to calling [setRxThreads()] 9.10.2 nCoresRV nCoresRV Number of cores used for the simulation of the sigma variables. By default this is 1. To reproduce the results you need to run on the same platform with the same number of cores. This is the reason this is set to be one, regardless of what the number of cores are used in threaded ODE solving. 9.10.3 nLlikAlloc nLlikAlloc The number of log likelihood endpoints that are used in the model. This allows independent log likelihood per endpoint in focei for nlmixr2. It likely shouldn’t be set, though it won’t hurt anything if you do (just may take up more memory for larger allocations). 9.10.4 useStdPow useStdPow This uses C’s pow for exponentiation instead of R’s R_pow or R_pow_di. By default this is FALSE 9.10.5 ss2cancelAllPending ss2cancelAllPending When TRUE the SS=2 event type cancels all pending doses like SS=1. When FALSE the pending doses not canceled with SS=2 (the infusions started before SS=2 occurred are canceled, though). 9.10.6 addlKeepsCov addlKeepsCov This determines if the additional dosing items repeats the dose only (FALSE) or keeps the covariates at the record of the dose (TRUE) 9.10.7 addlDropSs addlDropSs When there are steady state doses with an addl specification the steady state flag is dropped with repeated doses (when TRUE) or retained (when FALSE) 9.10.8 ssAtDoseTime ssAtDoseTime Boolean that when TRUE back calculates the steady concentration at the actual time of dose, otherwise when FALSE the doses are shifted 9.10.9 naTimeHandle naTimeHandle Determines what time of handling happens when the time becomes NA: current options are: ignore this ignores the NA time input and passes it through. warn (default) this will produce a warning at the end of the solve, but continues solving passing through the NA time error this will stop this solve if this is not a parallel solved ODE (otherwise stopping can crash R) "],["output.html", "Chapter 10 rxode2 output 10.1 Using rxode2 data frames 10.2 Updating the data-set interactively", " Chapter 10 rxode2 output 10.1 Using rxode2 data frames 10.1.1 Creating an interactive data frame rxode2 supports returning a solved object that is a modified data-frame. This is done by the predict(), solve(), or rxSolve() methods. library(rxode2) library(units) ### Setup example model mod1 &lt;- function() { ini({ # central KA &lt;- 2.94E-01 CL &lt;- 1.86E+01 # peripheral V2 &lt;- 4.02E+01 Q &lt;- 1.05E+01 V3 &lt;- 2.97E+02 # effects Kin &lt;- 1 Kout &lt;- 1 EC50 &lt;- 200 }) model({ C2 &lt;- centr/V2 C3 &lt;- peri/V3 d/dt(depot) &lt;- -KA*depot d/dt(centr) &lt;- KA*depot - CL*C2 - Q*C2 + Q*C3 d/dt(peri) &lt;- Q*C2 - Q*C3 d/dt(eff) &lt;- Kin - Kout*(1-C2/(EC50+C2))*eff eff(0) &lt;- 1 }) } ### Seup parameters and initial conditions ### Setup dosing event information ev &lt;- et(amountUnits=&quot;mg&quot;, timeUnits = &quot;hours&quot;) %&gt;% et(amt=10000, addl=9, ii=12) %&gt;% et(amt=20000, addl=4, time=120, ii=24) %&gt;% et(0:240) ### Now solve x &lt;- predict(mod1, ev) #&gt; using C compiler: ‘gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’ x #&gt; ── Solved rxode2 object ── #&gt; ── Parameters (x$params): ── #&gt; KA CL V2 Q V3 Kin Kout EC50 #&gt; 0.294 18.600 40.200 10.500 297.000 1.000 1.000 200.000 #&gt; ── Initial Conditions (x$inits): ── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ── #&gt; # A tibble: 241 × 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.23 #&gt; 5 4 44.5 5.98 3085. 1789. 1776. 1.23 #&gt; 6 5 36.5 7.18 2299. 1467. 2132. 1.21 #&gt; # ℹ 235 more rows 10.1.2 rxode2 solved object properties 10.1.3 Using the solved object as a simple data frame The solved object acts as a data.frame or tbl that can be filtered by dpylr. For example you could filter it easily. library(dplyr) #&gt; #&gt; Attaching package: &#39;dplyr&#39; #&gt; The following objects are masked from &#39;package:stats&#39;: #&gt; #&gt; filter, lag #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; intersect, setdiff, setequal, union ### You can drop units for comparisons and filtering x &lt;- mod1 %&gt;% solve(ev) %&gt;% drop_units() %&gt;% filter(time &lt;= 3) %&gt;% as_tibble() ### or keep them and compare with the proper units. x &lt;- mod1 %&gt;% solve(ev) %&gt;% filter(time &lt;= set_units(3, hr)) %&gt;% as_tibble() x #&gt; # A tibble: 4 × 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.23 10.2 Updating the data-set interactively However it isn’t just a simple data object. You can use the solved object to update parameters on the fly, or even change the sampling time. First we need to recreate the original solved system: x &lt;- mod1 %&gt;% solve(ev) print(x) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; KA CL V2 Q V3 Kin Kout EC50 #&gt; 0.294 18.600 40.200 10.500 297.000 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ── #&gt; # A tibble: 241 × 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.23 #&gt; 5 4 44.5 5.98 3085. 1789. 1776. 1.23 #&gt; 6 5 36.5 7.18 2299. 1467. 2132. 1.21 #&gt; # ℹ 235 more rows 10.2.1 Modifying observation times for rxode2 Notice that the initial effect is now 2. You can also change the sampling times easily by this method by changing t or time. For example: x$t &lt;- seq(0,5,length.out=20) print(x) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; KA CL V2 Q V3 Kin Kout EC50 #&gt; 0.294 18.600 40.200 10.500 297.000 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ── #&gt; # A tibble: 20 × 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 0.263 16.8 0.0817 9255. 677. 24.3 1.01 #&gt; 3 0.526 29.5 0.299 8566. 1187. 88.7 1.03 #&gt; 4 0.789 38.9 0.615 7929. 1562. 183. 1.06 #&gt; 5 1.05 45.5 1.00 7338. 1830. 298. 1.09 #&gt; 6 1.32 50.1 1.44 6792. 2013. 427. 1.12 #&gt; # ℹ 14 more rows plot(x) 10.2.2 Modifying simulation parameters You can also access or change parameters by the $ operator. For example, accessing KA can be done by: x$KA #&gt; [1] 0.294 And you may change it by assigning it to a new value. x$KA &lt;- 1 print(x) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; KA CL V2 Q V3 Kin Kout EC50 #&gt; 1.0 18.6 40.2 10.5 297.0 1.0 1.0 200.0 #&gt; ── Initial Conditions ($inits): ── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ── #&gt; # A tibble: 20 × 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 0.263 52.2 0.261 7686. 2098. 77.6 1.03 #&gt; 3 0.526 83.3 0.900 5908. 3348. 267. 1.09 #&gt; 4 0.789 99.8 1.75 4541. 4010. 519. 1.15 #&gt; 5 1.05 106. 2.69 3490. 4273. 800. 1.21 #&gt; 6 1.32 106. 3.66 2683. 4272. 1086. 1.26 #&gt; # ℹ 14 more rows plot(x) You can access/change all the parameters, initialization(s) or events with the $params, $inits, $events accessor syntax, similar to what is used above. This syntax makes it easy to update and explore the effect of various parameters on the solved object. "],["simulation.html", "Chapter 11 Simulation 11.1 Single Subject solving 11.2 Population Simulations with rxode2 11.3 Simulation of Clinical Trials 11.4 Using prior data for solving", " Chapter 11 Simulation 11.1 Single Subject solving Originally, rxode2 was only created to solve ODEs for one individual. That is a single system without any changes in individual parameters. Of course this is still supported, the classic examples are found in rxode2 intro. This article discusses the differences between multiple subject and single subject solving. There are three differences: Single solving does not solve each ID in parallel Single solving lacks the id column in parameters($params) as well as in the actual dataset. Single solving allows parameter exploration easier because each parameter can be modified. With multiple subject solves, you have to make sure to update each individual parameter. The first obvious difference is in speed; With multiple subjects you can run each subject ID in parallel. For more information and examples of the speed gains with multiple subject solving see the Speeding up rxode2 vignette. The next difference is the amount of information output in the final data. Taking the 2 compartment indirect response model originally in the tutorial: library(rxode2) mod1 &lt;- function() { ini({ KA=2.94E-01 CL=1.86E+01 V2=4.02E+01 Q=1.05E+01 V3=2.97E+02 Kin=1 Kout=1 EC50=200 }) model({ C2 = centr/V2 C3 = peri/V3 d/dt(depot) =-KA*depot d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3 d/dt(peri) = Q*C2 - Q*C3 d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff eff(0) = 1 }) } et &lt;- et(amount.units=&#39;mg&#39;, time.units=&#39;hours&#39;) %&gt;% et(dose=10000, addl=9, ii=12) %&gt;% et(amt=20000, nbr.doses=5, start.time=120, dosing.interval=24) %&gt;% et(0:240) # sampling Now a simple solve x &lt;- rxSolve(mod1, et) x #&gt; ── Solved rxode2 object ── #&gt; ── Parameters (x$params): ── #&gt; KA CL V2 Q V3 Kin Kout EC50 #&gt; 0.294 18.600 40.200 10.500 297.000 1.000 1.000 200.000 #&gt; ── Initial Conditions (x$inits): ── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ── #&gt; # A tibble: 241 × 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.23 #&gt; 5 4 44.5 5.98 3085. 1789. 1776. 1.23 #&gt; 6 5 36.5 7.18 2299. 1467. 2132. 1.21 #&gt; # ℹ 235 more rows print(x) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; KA CL V2 Q V3 Kin Kout EC50 #&gt; 0.294 18.600 40.200 10.500 297.000 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ── #&gt; # A tibble: 241 × 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.23 #&gt; 5 4 44.5 5.98 3085. 1789. 1776. 1.23 #&gt; 6 5 36.5 7.18 2299. 1467. 2132. 1.21 #&gt; # ℹ 235 more rows plot(x, C2, eff) To better see the differences between the single solve, you can solve for 2 individuals x2 &lt;- rxSolve(mod1, et %&gt;% et(id=1:2), params=data.frame(CL=c(18.6, 7.6))) print(x2) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; # A tibble: 2 × 9 #&gt; id KA CL V2 Q V3 Kin Kout EC50 #&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0.294 18.6 40.2 10.5 297 1 1 200 #&gt; 2 2 0.294 7.6 40.2 10.5 297 1 1 200 #&gt; ── Initial Conditions ($inits): ── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ── #&gt; # A tibble: 482 × 8 #&gt; id time C2 C3 depot centr peri eff #&gt; &lt;int&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0 0 0 10000 0 0 1 #&gt; 2 1 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 1 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 1 3 51.9 4.46 4140. 2087. 1324. 1.23 #&gt; 5 1 4 44.5 5.98 3085. 1789. 1776. 1.23 #&gt; 6 1 5 36.5 7.18 2299. 1467. 2132. 1.21 #&gt; # ℹ 476 more rows plot(x2, C2, eff) By observing the two solves, you can see: A multiple subject solve contains the id column both in the data frame and then data frame of parameters for each subject. The last feature that is not as obvious, modifying the individual parameters. For single subject data, you can modify the rxode2 data frame changing initial conditions and parameter values as if they were part of the data frame, as described in the rxode2 Data Frames. For multiple subject solving, this feature still works, but requires care when supplying each individual’s parameter value, otherwise you may change the solve and drop parameter for key individuals. 11.1.1 Summary of Single solve vs Multiple subject solving Feature Single Subject Solve Multiple Subject Solve Parallel None Each Subject $params data.frame with one parameter value data.frame with one parameter per subject (w/ID column) solved data Can modify individual parameters with $ syntax Have to modify all the parameters to update solved object 11.2 Population Simulations with rxode2 11.2.1 Simulation of Variability with rxode2 In pharmacometrics the nonlinear-mixed effect modeling software (like nlmixr) characterizes the between-subject variability. With this between subject variability you can simulate new subjects. Assuming that you have a 2-compartment, indirect response model, you can set create an rxode2 model describing this system below: 11.2.1.1 Setting up the rxode2 model library(rxode2) set.seed(32) rxSetSeed(32) mod &lt;- function() { ini({ KA &lt;- 2.94E-01 TCl &lt;- 1.86E+01 # between subject variability eta.Cl ~ 0.4^2 V2 &lt;- 4.02E+01 Q &lt;- 1.05E+01 V3 &lt;- 2.97E+02 Kin &lt;- 1 Kout &lt;- 1 EC50 &lt;- 200 }) model({ C2 &lt;- centr/V2 C3 &lt;- peri/V3 CL &lt;- TCl*exp(eta.Cl) ## This is coded as a variable in the model d/dt(depot) &lt;- -KA*depot d/dt(centr) &lt;- KA*depot - CL*C2 - Q*C2 + Q*C3 d/dt(peri) &lt;- Q*C2 - Q*C3 d/dt(eff) &lt;- Kin - Kout*(1-C2/(EC50+C2))*eff eff(0) &lt;- 1 }) } 11.2.1.2 Simulating The next step to simulate is to create the dosing regimen for overall simulation: ev &lt;- et(amountUnits=&quot;mg&quot;, timeUnits=&quot;hours&quot;) %&gt;% et(amt=10000, cmt=&quot;centr&quot;) If you wish, you can also add sampling times (though rxode2 can fill these in for you): ev &lt;- ev %&gt;% et(0,48, length.out=100) Note the et takes similar arguments as seq when adding sampling times. There are more methods to adding sampling times and events to make complex dosing regimens (See the event vignette). This includes ways to add variability to the both the sampling and dosing times). Once this is complete you can simulate using the rxSolve routine: sim &lt;- rxSolve(mod, ev, nSub=100) #&gt; using C compiler: ‘gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’ To quickly look and customize your simulation you use the default plot routine. Since this is an rxode2 object, it will create a ggplot2 object that you can modify as you wish. The extra parameter to the plot tells rxode2/R what piece of information you are interested in plotting. In this case, we are interested in looking at the derived parameter C2: 11.2.1.3 Checking the simulation with plot library(ggplot2) ### The plots from rxode2 are ggplots so they can be modified with ### standard ggplot commands. plot(sim, C2, log=&quot;y&quot;) + ylab(&quot;Central Compartment&quot;) Of course this additional parameter could also be a state value, like eff: ### They also takes many of the standard plot arguments; See ?plot plot(sim, eff, ylab=&quot;Effect&quot;) Or you could even look at the two side-by-side: plot(sim, C2, eff) Or stack them with patchwork library(patchwork) plot(sim, C2, log=&quot;y&quot;) / plot(sim, eff) 11.2.1.4 Processing the data to create summary plots Usually in pharmacometric simulations it is not enough to simply simulate the system. We have to do something easier to digest, like look at the central and extreme tendencies of the simulation. Since the rxode2 solve object is a type of data frame It is now straightforward to perform calculations and generate plots with the simulated data. You can Below, the 5th, 50th, and 95th percentiles of the simulated data are plotted. confint(sim, &quot;C2&quot;, level=0.95) %&gt;% plot(ylab=&quot;Central Concentration&quot;, log=&quot;y&quot;) #&gt; ! in order to put confidence bands around the intervals, you need at least 2500 simulations #&gt; summarizing data...done confint(sim, &quot;eff&quot;, level=0.95) %&gt;% plot(ylab=&quot;Effect&quot;) #&gt; ! in order to put confidence bands around the intervals, you need at least 2500 simulations #&gt; summarizing data...done Note that you can see the parameters that were simulated for the example head(sim$param) #&gt; sim.id KA TCl V2 Q V3 Kin Kout EC50 eta.Cl #&gt; 1 1 0.294 18.6 40.2 10.5 297 1 1 200 -0.61812276 #&gt; 2 2 0.294 18.6 40.2 10.5 297 1 1 200 0.08180225 #&gt; 3 3 0.294 18.6 40.2 10.5 297 1 1 200 0.90546786 #&gt; 4 4 0.294 18.6 40.2 10.5 297 1 1 200 0.47668266 #&gt; 5 5 0.294 18.6 40.2 10.5 297 1 1 200 0.15939498 #&gt; 6 6 0.294 18.6 40.2 10.5 297 1 1 200 -0.14083691 11.2.1.5 Simulation of unexplained variability (sigma) In addition to conveniently simulating between subject variability, you can also easily simulate unexplained variability. One way to do that is to create a rxode2 model with the endpoints defined. Model piping can do this while keeping the model intact: mod2 &lt;- mod %&gt;% model(eff ~ add(eff.sd), append=TRUE) %&gt;% model(C2 ~ prop(prop.sd), append=TRUE) %&gt;% ini(eff.sd=sqrt(0.1), prop.sd=sqrt(0.1)) #&gt; ℹ add residual parameter `eff.sd` and set estimate to 1 #&gt; ℹ add residual parameter `prop.sd` and set estimate to 1 #&gt; ℹ change initial estimate of `eff.sd` to `0.316227766016838` #&gt; ℹ change initial estimate of `prop.sd` to `0.316227766016838` You can see how the dataset should be defined with $multipleEndpoint: mod2$multipleEndpoint #&gt; variable cmt dvid* #&gt; 1 eff ~ … cmt=&#39;eff&#39; or cmt=4 dvid=&#39;eff&#39; or dvid=1 #&gt; 2 C2 ~ … cmt=&#39;C2&#39; or cmt=5 dvid=&#39;C2&#39; or dvid=2 Here you see the endpoints should be defined for eff and C2: ev &lt;- et(amountUnits=&quot;mg&quot;, timeUnits=&quot;hours&quot;) %&gt;% et(amt=10000, cmt=&quot;centr&quot;) %&gt;% et(seq(0,48, length.out=100), cmt=&quot;eff&quot;) %&gt;% et(seq(0,48, length.out=100), cmt=&quot;C2&quot;) Which allows you to solve the system: sim &lt;- rxSolve(mod2, ev, nSub=100) #&gt; using C compiler: ‘gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’ Since this is simulated from a model with the residual specification included and a multiple endpoint model, you can summarize for each endpoint by simply taking a confidence interval of \"sim\": s &lt;- confint(sim, &quot;sim&quot;) #&gt; ! in order to put confidence bands around the intervals, you need at least 2500 simulations #&gt; summarizing data...done plot(s) If you want to subset to a specific endpoint, like eff you can create the confidence interval for only that endpoint by using the specification sim.eff, where the endpoint name is separated from sim by a dot: seff &lt;- confint(sim, &quot;sim.eff&quot;) #&gt; ! in order to put confidence bands around the intervals, you need at least 2500 simulations #&gt; summarizing data...done plot(seff) 11.2.1.6 Simulation of Individuals Sometimes you may want to match the dosing and observations of individuals in a clinical trial. To do this you will have to create a data.frame using the rxode2 event specification as well as an ID column to indicate an individual. The rxode2 event vignette talks more about how these datasets should be created. library(dplyr) ev1 &lt;- et(amountUnits=&quot;mg&quot;, timeUnits=&quot;hours&quot;) %&gt;% et(amt=10000, cmt=2) %&gt;% et(0,48,length.out=10) ev2 &lt;- et(amountUnits=&quot;mg&quot;, timeUnits=&quot;hours&quot;) %&gt;% et(amt=5000, cmt=2) %&gt;% et(0,48,length.out=8) dat &lt;- rbind(data.frame(ID=1, ev1$get.EventTable()), data.frame(ID=2, ev2$get.EventTable())) ### Note the number of subject is not needed since it is determined by the data sim &lt;- rxSolve(mod, dat) sim %&gt;% select(id, time, eff, C2) #&gt; id time eff C2 #&gt; 1 1 0.000000 [h] 1.000000 248.7562189 #&gt; 2 1 5.333333 [h] 1.028494 2.0252374 #&gt; 3 1 10.666667 [h] 1.006985 1.3313641 #&gt; 4 1 16.000000 [h] 1.005916 1.1507552 #&gt; 5 1 21.333333 [h] 1.005117 0.9953618 #&gt; 6 1 26.666667 [h] 1.004426 0.8609553 #&gt; 7 1 32.000000 [h] 1.003828 0.7446975 #&gt; 8 1 37.333333 [h] 1.003311 0.6441382 #&gt; 9 1 42.666667 [h] 1.002864 0.5571571 #&gt; 10 1 48.000000 [h] 1.002477 0.4819218 #&gt; 11 2 0.000000 [h] 1.000000 124.3781095 #&gt; 12 2 6.857143 [h] 1.025417 3.0885681 #&gt; 13 2 13.714286 [h] 1.009566 1.8539299 #&gt; 14 2 20.571429 [h] 1.008138 1.5920429 #&gt; 15 2 27.428571 [h] 1.007015 1.3724957 #&gt; 16 2 34.285714 [h] 1.006048 1.1832665 #&gt; 17 2 41.142857 [h] 1.005214 1.0201272 #&gt; 18 2 48.000000 [h] 1.004495 0.8794807 11.3 Simulation of Clinical Trials By either using a simple single event table, or data from a clinical trial as described above, a complete clinical trial simulation can be performed. Typically in clinical trial simulations you want to account for the uncertainty in the fixed parameter estimates, and even the uncertainty in both your between subject variability as well as the unexplained variability. rxode2 allows you to account for these uncertainties by simulating multiple virtual “studies,” specified by the parameter nStud. Each of these studies samples a realization of fixed effect parameters and covariance matrices for the between subject variability(omega) and unexplained variabilities (sigma). Depending on the information you have from the models, there are a few strategies for simulating a realization of the omega and sigma matrices. The first strategy occurs when either there is not any standard errors for standard deviations (or related parameters), or there is a modeled correlation in the model you are simulating from. In that case the suggested strategy is to use the inverse Wishart (parameterized to scale to the conjugate prior)/scaled inverse chi distribution. this approach uses a single parameter to inform the variability of the covariance matrix sampled (the degrees of freedom). The second strategy occurs if you have standard errors on the variance/standard deviation with no modeled correlations in the covariance matrix. In this approach you perform separate simulations for the standard deviations and the correlation matrix. First you simulate the variance/standard deviation components in the thetaMat multivariate normal simulation. After simulation and transformation to standard deviations, a correlation matrix is simulated using the degrees of freedom of your covariance matrix. Combining the simulated standard deviation with the simulated correlation matrix will give a simulated covariance matrix. For smaller dimension covariance matrices (dimension &lt; 10x10) it is recommended you use the lkj distribution to simulate the correlation matrix. For higher dimension covariance matrices it is suggested you use the inverse wishart distribution (transformed to a correlation matrix) for the simulations. The covariance/variance prior is simulated from rxode2s cvPost() function. 11.3.1 Simulation from inverse Wishart correlations An example of this simulation is below: ### Creating covariance matrix tmp &lt;- matrix(rnorm(8^2), 8, 8) tMat &lt;- tcrossprod(tmp, tmp) / (8 ^ 2) dimnames(tMat) &lt;- list(NULL, names(mod2$theta)[1:8]) sim &lt;- rxSolve(mod2, ev, nSub=100, thetaMat=tMat, nStud=10, dfSub=10, dfObs=100) s &lt;-sim %&gt;% confint(&quot;sim&quot;) #&gt; summarizing data...done plot(s) If you wish you can see what omega and sigma was used for each virtual study by accessing them in the solved data object with $omega.list and $sigma.list: head(sim$omegaList) #&gt; [[1]] #&gt; eta.Cl #&gt; eta.Cl 0.1676778 #&gt; #&gt; [[2]] #&gt; eta.Cl #&gt; eta.Cl 0.2917085 #&gt; #&gt; [[3]] #&gt; eta.Cl #&gt; eta.Cl 0.1776813 #&gt; #&gt; [[4]] #&gt; eta.Cl #&gt; eta.Cl 0.1578682 #&gt; #&gt; [[5]] #&gt; eta.Cl #&gt; eta.Cl 0.1845614 #&gt; #&gt; [[6]] #&gt; eta.Cl #&gt; eta.Cl 0.3282268 head(sim$sigmaList) #&gt; [[1]] #&gt; rxerr.eff rxerr.C2 #&gt; rxerr.eff 1.12416983 0.04197039 #&gt; rxerr.C2 0.04197039 0.97293971 #&gt; #&gt; [[2]] #&gt; rxerr.eff rxerr.C2 #&gt; rxerr.eff 0.84311199 -0.06277998 #&gt; rxerr.C2 -0.06277998 1.22140938 #&gt; #&gt; [[3]] #&gt; rxerr.eff rxerr.C2 #&gt; rxerr.eff 0.9834771 0.1060251 #&gt; rxerr.C2 0.1060251 1.0024751 #&gt; #&gt; [[4]] #&gt; rxerr.eff rxerr.C2 #&gt; rxerr.eff 1.25556975 0.07690868 #&gt; rxerr.C2 0.07690868 0.90991261 #&gt; #&gt; [[5]] #&gt; rxerr.eff rxerr.C2 #&gt; rxerr.eff 1.116261 -0.184748 #&gt; rxerr.C2 -0.184748 1.320288 #&gt; #&gt; [[6]] #&gt; rxerr.eff rxerr.C2 #&gt; rxerr.eff 0.93539238 0.07270049 #&gt; rxerr.C2 0.07270049 0.98648424 You can also see the parameter realizations from the $params data frame. 11.3.2 Simulate using variance/standard deviation standard errors Lets assume we wish to simulate from the nonmem run included in xpose First we setup the model; Since we are taking this from nonmem and would like to use the more free-form style from the classic rxode2 model we start from the classic model: rx1 &lt;- rxode2({ cl &lt;- tcl*(1+crcl.cl*(CLCR-65)) * exp(eta.cl) v &lt;- tv * WT * exp(eta.v) ka &lt;- tka * exp(eta.ka) ipred &lt;- linCmt() obs &lt;- ipred * (1 + prop.sd) + add.sd }) #&gt; using C compiler: ‘gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’ Next we input the estimated parameters: theta &lt;- c(tcl=2.63E+01, tv=1.35E+00, tka=4.20E+00, tlag=2.08E-01, prop.sd=2.05E-01, add.sd=1.06E-02, crcl.cl=7.17E-03, ## Note that since we are using the separation strategy the ETA variances are here too eta.cl=7.30E-02, eta.v=3.80E-02, eta.ka=1.91E+00) And also their covariances; To me, the easiest way to create a named covariance matrix is to use lotri(): thetaMat &lt;- lotri( tcl + tv + tka + tlag + prop.sd + add.sd + crcl.cl + eta.cl + eta.v + eta.ka ~ c(7.95E-01, 2.05E-02, 1.92E-03, 7.22E-02, -8.30E-03, 6.55E-01, -3.45E-03, -6.42E-05, 3.22E-03, 2.47E-04, 8.71E-04, 2.53E-04, -4.71E-03, -5.79E-05, 5.04E-04, 6.30E-04, -3.17E-06, -6.52E-04, -1.53E-05, -3.14E-05, 1.34E-05, -3.30E-04, 5.46E-06, -3.15E-04, 2.46E-06, 3.15E-06, -1.58E-06, 2.88E-06, -1.29E-03, -7.97E-05, 1.68E-03, -2.75E-05, -8.26E-05, 1.13E-05, -1.66E-06, 1.58E-04, -1.23E-03, -1.27E-05, -1.33E-03, -1.47E-05, -1.03E-04, 1.02E-05, 1.67E-06, 6.68E-05, 1.56E-04, 7.69E-02, -7.23E-03, 3.74E-01, 1.79E-03, -2.85E-03, 1.18E-05, -2.54E-04, 1.61E-03, -9.03E-04, 3.12E-01)) evw &lt;- et(amount.units=&quot;mg&quot;, time.units=&quot;hours&quot;) %&gt;% et(amt=100) %&gt;% ## For this problem we will simulate with sampling windows et(list(c(0, 0.5), c(0.5, 1), c(1, 3), c(3, 6), c(6, 12))) %&gt;% et(id=1:1000) ### From the run we know that: ### total number of observations is: 476 ### Total number of individuals: 74 sim &lt;- rxSolve(rx1, theta, evw, nSub=100, nStud=10, thetaMat=thetaMat, ## Match boundaries of problem thetaLower=0, sigma=c(&quot;prop.sd&quot;, &quot;add.sd&quot;), ## Sigmas are standard deviations sigmaXform=&quot;identity&quot;, # default sigma xform=&quot;identity&quot; omega=c(&quot;eta.cl&quot;, &quot;eta.v&quot;, &quot;eta.ka&quot;), ## etas are variances omegaXform=&quot;variance&quot;, # default omega xform=&quot;variance&quot; iCov=data.frame(WT=rnorm(1000, 70, 15), CLCR=rnorm(1000, 65, 25)), dfSub=74, dfObs=476); #&gt; ℹ thetaMat has too many items, ignored: &#39;tlag&#39; print(sim) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; # A tibble: 10,000 × 9 #&gt; sim.id id tcl crcl.cl eta.cl tv eta.v tka eta.ka #&gt; &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 28.5 1.07 -0.209 1.64 0.572 4.45 -0.681 #&gt; 2 1 2 28.5 1.07 -1.26 1.64 -0.517 4.45 -0.0415 #&gt; 3 1 3 28.5 1.07 0.241 1.64 0.0818 4.45 1.23 #&gt; 4 1 4 28.5 1.07 0.150 1.64 -1.70 4.45 0.196 #&gt; 5 1 5 28.5 1.07 0.170 1.64 0.713 4.45 -0.502 #&gt; 6 1 6 28.5 1.07 1.01 1.64 -0.185 4.45 -0.00501 #&gt; 7 1 7 28.5 1.07 -0.700 1.64 -0.0111 4.45 0.0739 #&gt; 8 1 8 28.5 1.07 1.49 1.64 0.438 4.45 0.640 #&gt; 9 1 9 28.5 1.07 0.381 1.64 -1.15 4.45 0.575 #&gt; 10 1 10 28.5 1.07 -0.142 1.64 0.797 4.45 0.0448 #&gt; # ℹ 9,990 more rows #&gt; ── Initial Conditions ($inits): ── #&gt; named numeric(0) #&gt; #&gt; Simulation with uncertainty in: #&gt; • parameters ($thetaMat for changes) #&gt; • omega matrix ($omegaList) #&gt; • sigma matrix ($sigmaList) #&gt; #&gt; ── First part of data (object): ── #&gt; # A tibble: 50,000 × 10 #&gt; sim.id id time cl v ka ipred obs WT CLCR #&gt; &lt;int&gt; &lt;int&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 0.0155 128. 181. 2.25 0.0188 0.529 62.2 69.3 #&gt; 2 1 1 0.749 128. 181. 2.25 0.325 1.09 62.2 69.3 #&gt; 3 1 1 1.02 128. 181. 2.25 0.310 0.908 62.2 69.3 #&gt; 4 1 1 3.41 128. 181. 2.25 0.0721 -0.769 62.2 69.3 #&gt; 5 1 1 7.81 128. 181. 2.25 0.00323 0.0646 62.2 69.3 #&gt; 6 1 2 0.0833 357. 35.0 4.27 0.562 1.19 35.7 105. #&gt; # ℹ 49,994 more rows ### Notice that the simulation time-points change for the individual ### If you want the same sampling time-points you can do that as well: evw &lt;- et(amount.units=&quot;mg&quot;, time.units=&quot;hours&quot;) %&gt;% et(amt=100) %&gt;% et(0, 24, length.out=50) %&gt;% et(id=1:100) sim &lt;- rxSolve(rx1, theta, evw, nSub=100, nStud=10, thetaMat=thetaMat, ## Match boundaries of problem thetaLower=0, sigma=c(&quot;prop.sd&quot;, &quot;add.sd&quot;), ## Sigmas are standard deviations sigmaXform=&quot;identity&quot;, # default sigma xform=&quot;identity&quot; omega=c(&quot;eta.cl&quot;, &quot;eta.v&quot;, &quot;eta.ka&quot;), ## etas are variances omegaXform=&quot;variance&quot;, # default omega xform=&quot;variance&quot; iCov=data.frame(WT=rnorm(100, 70, 15), CLCR=rnorm(100, 65, 25)), dfSub=74, dfObs=476, resample=TRUE) #&gt; ℹ thetaMat has too many items, ignored: &#39;tlag&#39; s &lt;-sim %&gt;% confint(c(&quot;ipred&quot;)) #&gt; summarizing data... #&gt; done plot(s) 11.3.3 Simulate without uncertainty in omega or sigma parameters If you do not wish to sample from the prior distributions of either the omega or sigma matrices, you can turn off this feature by specifying the simVariability = FALSE option when solving: sim &lt;- rxSolve(mod2, ev, nSub=100, thetaMat=tMat, nStud=10, simVariability=FALSE) s &lt;-sim %&gt;% confint(c(&quot;centr&quot;, &quot;eff&quot;)) #&gt; summarizing data...done plot(s) Note since realizations of omega and sigma were not simulated, $omegaList and $sigmaList both return NULL. 11.4 Using prior data for solving rxode2 can use a single subject or multiple subjects with a single event table to solve ODEs. Additionally, rxode2 can use an arbitrary data frame with individualized events. For example when using nlmixr, you could use the theo_sd data frame library(rxode2) library(nlmixr2data) ### Load data from nlmixr d &lt;- theo_sd ### Create rxode2 model theo &lt;- function() { ini({ tka &lt;- 0.45 # Log Ka tcl &lt;- 1 # Log Cl tv &lt;- 3.45 # Log V eta.ka ~ 0.6 eta.cl ~ 0.3 eta.v ~ 0.1 }) model({ ka &lt;- exp(tka + eta.ka) cl &lt;- exp(tcl + eta.cl) v &lt;- exp(tv + eta.v) d/dt(depot) = -ka * depot d/dt(center) = ka * depot - cl / v * center cp = center / v }) } ### Create parameter dataset library(dplyr) parsDf &lt;- tribble( ~ eta.ka, ~ eta.cl, ~ eta.v, 0.105, -0.487, -0.080, 0.221, 0.144, 0.021, 0.368, 0.031, 0.058, -0.277, -0.015, -0.007, -0.046, -0.155, -0.142, -0.382, 0.367, 0.203, -0.791, 0.160, 0.047, -0.181, 0.168, 0.096, 1.420, 0.042, 0.012, -0.738, -0.391, -0.170, 0.790, 0.281, 0.146, -0.527, -0.126, -0.198) %&gt;% mutate(tka = 0.451, tcl = 1.017, tv = 3.449) ### Now solve the dataset solveData &lt;- rxSolve(theo, parsDf, d) #&gt; ℹ parameter labels from comments will be replaced by &#39;label()&#39; #&gt; using C compiler: ‘gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’ plot(solveData, cp) print(solveData) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; # A tibble: 12 × 7 #&gt; id tka tcl tv eta.ka eta.cl eta.v #&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0.451 1.02 3.45 0.309 0.561 0.0703 #&gt; 2 2 0.451 1.02 3.45 0.251 -0.0937 -0.298 #&gt; 3 3 0.451 1.02 3.45 -0.564 -0.789 -0.0133 #&gt; 4 4 0.451 1.02 3.45 1.22 -0.684 -0.0915 #&gt; 5 5 0.451 1.02 3.45 -0.342 0.471 0.0190 #&gt; 6 6 0.451 1.02 3.45 1.60 -0.0631 0.106 #&gt; 7 7 0.451 1.02 3.45 -0.476 1.16 -0.0539 #&gt; 8 8 0.451 1.02 3.45 0.782 0.617 0.0361 #&gt; 9 9 0.451 1.02 3.45 0.921 0.119 -0.0417 #&gt; 10 10 0.451 1.02 3.45 -0.710 -0.265 0.0798 #&gt; 11 11 0.451 1.02 3.45 -0.0164 -0.141 0.675 #&gt; 12 12 0.451 1.02 3.45 -0.183 -0.427 0.329 #&gt; ── Initial Conditions ($inits): ── #&gt; depot center #&gt; 0 0 #&gt; ── First part of data (object): ── #&gt; # A tibble: 132 × 8 #&gt; id time ka cl v cp depot center #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0 2.14 4.85 33.8 0 320. 0 #&gt; 2 1 0.25 2.14 4.85 33.8 3.85 188. 130. #&gt; 3 1 0.57 2.14 4.85 33.8 6.36 94.6 215. #&gt; 4 1 1.12 2.14 4.85 33.8 7.72 29.2 261. #&gt; 5 1 2.02 2.14 4.85 33.8 7.47 4.26 252. #&gt; 6 1 3.82 2.14 4.85 33.8 5.87 0.0909 198. #&gt; # ℹ 126 more rows ### Of course the fasest way to solve if you don&#39;t care about the rxode2 extra parameters is solveData &lt;- rxSolve(theo, parsDf, d, returnType=&quot;data.frame&quot;) #&gt; ℹ parameter labels from comments will be replaced by &#39;label()&#39; ### solved data dplyr::as_tibble(solveData) #&gt; # A tibble: 132 × 8 #&gt; id time ka cl v cp depot center #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0 2.19 3.49 30.2 0 3.20e+ 2 0 #&gt; 2 1 0.25 2.19 3.49 30.2 4.41 1.85e+ 2 133. #&gt; 3 1 0.57 2.19 3.49 30.2 7.28 9.18e+ 1 219. #&gt; 4 1 1.12 2.19 3.49 30.2 8.88 2.75e+ 1 268. #&gt; 5 1 2.02 2.19 3.49 30.2 8.73 3.82e+ 0 263. #&gt; 6 1 3.82 2.19 3.49 30.2 7.20 7.40e- 2 217. #&gt; 7 1 5.1 2.19 3.49 30.2 6.21 4.48e- 3 187. #&gt; 8 1 7.03 2.19 3.49 30.2 4.97 6.52e- 5 150. #&gt; 9 1 9.05 2.19 3.49 30.2 3.93 7.78e- 7 119. #&gt; 10 1 12.1 2.19 3.49 30.2 2.76 6.91e-10 83.2 #&gt; # ℹ 122 more rows data.table::data.table(solveData) #&gt; id time ka cl v cp depot center #&gt; 1: 1 0.00 2.191528 3.487816 30.15612 0.0000000 3.199920e+02 0.000000 #&gt; 2: 1 0.25 2.191528 3.487816 30.15612 4.4061936 1.850108e+02 132.873716 #&gt; 3: 1 0.57 2.191528 3.487816 30.15612 7.2754861 9.175521e+01 219.400454 #&gt; 4: 1 1.12 2.191528 3.487816 30.15612 8.8789725 2.748894e+01 267.755389 #&gt; 5: 1 2.02 2.191528 3.487816 30.15612 8.7345323 3.824416e+00 263.399632 #&gt; --- #&gt; 128: 12 5.07 2.515775 4.435929 27.84752 5.4815780 9.259920e-04 152.648334 #&gt; 129: 12 7.07 2.515775 4.435929 27.84752 3.9860963 6.045546e-06 111.002882 #&gt; 130: 12 9.03 2.515775 4.435929 27.84752 2.9171213 4.369604e-08 81.234584 #&gt; 131: 12 12.05 2.515775 4.435929 27.84752 1.8031415 4.791674e-09 50.213013 #&gt; 132: 12 24.15 2.515775 4.435929 27.84752 0.2623903 -2.694005e-10 7.306919 "],["examples.html", "Chapter 12 Examples 12.1 Prediction only models 12.2 Solved compartment models 12.3 Mixing Solved Systems and ODEs 12.4 Weight based dosing 12.5 Inter-occasion and other nesting examples 12.6 Transit compartment models", " Chapter 12 Examples This section is for example models to get you started in common simulation scenarios. 12.1 Prediction only models Prediction only models are simple to create. You use the rxode2 syntax without any ODE systems in them. A very simple example is a one-compartment model. library(rxode2) mod &lt;- function(){ model({ ipre &lt;- 10 * exp(-ke * t) }) } Solving the rxode2 models are the same as saving the simple ODE system, but faster of course. et &lt;- et(seq(0,24,length.out=50)) cmt1 &lt;- rxSolve(mod,et,params=c(ke=0.5)) #&gt; using C compiler: ‘gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’ cmt1 #&gt; ── Solved rxode2 object ── #&gt; ── Parameters (x$params): ── #&gt; ke #&gt; 0.5 #&gt; ── Initial Conditions (x$inits): ── #&gt; named numeric(0) #&gt; ── First part of data (object): ── #&gt; # A tibble: 50 × 2 #&gt; time ipre #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 10 #&gt; 2 0.490 7.83 #&gt; 3 0.980 6.13 #&gt; 4 1.47 4.80 #&gt; 5 1.96 3.75 #&gt; 6 2.45 2.94 #&gt; # ℹ 44 more rows 12.2 Solved compartment models Solved models are also simple to create. You simply place the linCmt() psuedo-function into your code. The linCmt() function figures out the type of model to use based on the parameter names specified. Most often, pharmacometric models are parameterized in terms of volume and clearances. Clearances are specified by NONMEM-style names of CL, Q, Q1, Q2, etc. or distributional clearances CLD, CLD2. Volumes are specified by Central (VC or V), Peripheral/Tissue (VP, VT). While more translations are available, some example translations are below: Another popular parameterization is in terms of micro-constants. rxode2 assumes compartment 1 is the central compartment. The elimination constant would be specified by K, Ke or Kel. Some example translations are below: The last parameterization possible is using alpha and V and/or A/B/C. Some example translations are below: Once the linCmt() sleuthing is complete, the 1, 2 or 3 compartment model solution is used as the value of linCmt(). The compartments where you can dose in a linear solved system are depot and central when there is an linear absorption constant in the model ka. Without any additional ODEs, these compartments are numbered depot=1 and central=2. When the absorption constant ka is missing, you may only dose to the central compartment. Without any additional ODEs the compartment number is central=1. These compartments take the same sort of events that a ODE model can take, and are discussed in the rxode2 events vignette. mod &lt;- function() { ini({ kel &lt;- 0.5 V &lt;- 1 }) model({ ipre &lt;- linCmt(V, kel) }) } This then acts as an ODE model; You specify a dose to the depot compartment and then solve the system: et &lt;- et(amt=10,time=0,cmt=depot) %&gt;% et(seq(0,24,length.out=50)) cmt1 &lt;- rxSolve(mod,et) #&gt; using C compiler: ‘gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’ cmt1 #&gt; ── Solved rxode2 object ── #&gt; ── Parameters (x$params): ── #&gt; kel V #&gt; 0.5 1.0 #&gt; ── Initial Conditions (x$inits): ── #&gt; named numeric(0) #&gt; ── First part of data (object): ── #&gt; # A tibble: 50 × 2 #&gt; time ipre #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 10 #&gt; 2 0.490 7.83 #&gt; 3 0.980 6.13 #&gt; 4 1.47 4.80 #&gt; 5 1.96 3.75 #&gt; 6 2.45 2.94 #&gt; # ℹ 44 more rows 12.3 Mixing Solved Systems and ODEs In addition to pure ODEs, you may mix solved systems and ODEs. The prior 2-compartment indirect response model can be simplified with a linCmt() function: library(rxode2) ## Setup example model mod1 &lt;-function() { model({ C2 = centr/V2 C3 = peri/V3 d/dt(depot) =-KA*depot d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3 d/dt(peri) = Q*C2 - Q*C3 d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff }) } ## Seup parameters and initial conditions theta &lt;- c(KA=2.94E-01, CL=1.86E+01, V2=4.02E+01, # central Q=1.05E+01, V3=2.97E+02, # peripheral Kin=1, Kout=1, EC50=200) # effects inits &lt;- c(eff=1) ## Setup dosing event information ev &lt;- et(amountUnits=&quot;mg&quot;, timeUnits=&quot;hours&quot;) %&gt;% et(amt=10000, addl=9, ii=12) %&gt;% et(amt=20000, addl=4, time=120, ii=24) %&gt;% add.sampling(0:240) ## Setup a mixed solved/ode system: mod2 &lt;- function() { model({ ## the order of variables do not matter, the type of compartmental ## model is determined by the parameters specified. C2 = linCmt(KA, CL, V2, Q, V3); eff(0) = 1 ## This specifies that the effect compartment starts at 1. d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; }) } This allows the indirect response model above to assign the 2-compartment model to the C2 variable and the used in the indirect response model. When mixing the solved systems and the ODEs, the solved system’s compartment is always the last compartment. This is because the solved system technically isn’t a compartment to be solved. Adding the dosing compartment to the end will not interfere with the actual ODE to be solved. Therefore,in the two-compartment indirect response model, the effect compartment is compartment #1 while the PK dosing compartment for the depot is compartment #2. This compartment model requires a new event table since the compartment number changed: ev &lt;- et(amountUnits=&#39;mg&#39;, timeUnits=&#39;hours&#39;) %&gt;% et(amt=10000, addl=9, ii=12, cmt=2) %&gt;% et(amt=20000, addl=4, time=120, ii=24, cmt=2) %&gt;% et(0:240) This can be solved with the following command: x &lt;- mod2 %&gt;% solve(theta, ev) #&gt; using C compiler: ‘gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’ print(x) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; KA CL V2 Q V3 Kin Kout EC50 #&gt; 0.294 18.600 40.200 10.500 297.000 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ── #&gt; eff #&gt; 1 #&gt; ── First part of data (object): ── #&gt; # A tibble: 241 × 3 #&gt; time C2 eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 249. 1 #&gt; 2 1 121. 1.35 #&gt; 3 2 60.3 1.38 #&gt; 4 3 31.0 1.28 #&gt; 5 4 17.0 1.18 #&gt; 6 5 10.2 1.11 #&gt; # ℹ 235 more rows Note this solving did not require specifying the effect compartment initial condition to be 1. Rather, this is already pre-specified by eff(0)=1. This can be solved for different initial conditions easily: x &lt;- mod2 %&gt;% solve(theta, ev,c(eff=2)) print(x) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; KA CL V2 Q V3 Kin Kout EC50 #&gt; 0.294 18.600 40.200 10.500 297.000 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ── #&gt; eff #&gt; 2 #&gt; ── First part of data (object): ── #&gt; # A tibble: 241 × 3 #&gt; time C2 eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 249. 2 #&gt; 2 1 121. 1.93 #&gt; 3 2 60.3 1.67 #&gt; 4 3 31.0 1.41 #&gt; 5 4 17.0 1.23 #&gt; 6 5 10.2 1.13 #&gt; # ℹ 235 more rows The rxode2 detective also does not require you to specify the variables in the linCmt() function if they are already defined in the block. Therefore, the following function will also work to solve the same system. mod3 &lt;- function() { ini({ KA &lt;- 2.94E-01 CL &lt;- 1.86E+01 V2 &lt;- 4.02E+01 Q &lt;- 1.05E+01 V3 &lt;- 2.97E+02 Kin &lt;- 1 Kout &lt;- 1 EC50 &lt;- 200 }) model({ # Since the parameters are in the ini block, put them in linCmt so # that the model is detected correctly C2 &lt;- linCmt(KA, CL, V2, Q, V3) eff(0) &lt;- 1 ## This specifies that the effect compartment starts at 1. d/dt(eff) &lt;- Kin - Kout*(1-C2/(EC50+C2))*eff; }) } x &lt;- mod3 %&gt;% solve(ev) print(x) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; KA CL V2 Q V3 Kin Kout EC50 #&gt; 0.294 18.600 40.200 10.500 297.000 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ── #&gt; eff #&gt; 1 #&gt; ── First part of data (object): ── #&gt; # A tibble: 241 × 3 #&gt; time C2 eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 249. 1 #&gt; 2 1 121. 1.35 #&gt; 3 2 60.3 1.38 #&gt; 4 3 31.0 1.28 #&gt; 5 4 17.0 1.18 #&gt; 6 5 10.2 1.11 #&gt; # ℹ 235 more rows Note that you do not specify the parameters when solving the system since they are built into the model, but you can override the parameters: x &lt;- mod3 %&gt;% solve(c(KA=10),ev) print(x) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; KA CL V2 Q V3 Kin Kout EC50 #&gt; 10.0 18.6 40.2 10.5 297.0 1.0 1.0 200.0 #&gt; ── Initial Conditions ($inits): ── #&gt; eff #&gt; 1 #&gt; ── First part of data (object): ── #&gt; # A tibble: 241 × 3 #&gt; time C2 eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 249. 1 #&gt; 2 1 121. 1.35 #&gt; 3 2 60.3 1.38 #&gt; 4 3 31.0 1.28 #&gt; 5 4 17.0 1.18 #&gt; 6 5 10.2 1.11 #&gt; # ℹ 235 more rows 12.4 Weight based dosing This is an example model for weight based dosing of daptomycin. Daptomycin is a cyclic lipopeptide antibiotic from fermented Streptomyces roseosporus. There are 3 stages for weight-based dosing simulations: - Create rxode2 model - Simulate Covariates - Create event table with weight-based dosing (merged back to covariates) 12.4.1 Creating a 2-compartment model in rxode2 library(rxode2) ## Note the time covariate is not included in the simulation m1 &lt;- function() { model({ CL ~ (1-0.2*SEX)*(0.807+0.00514*(CRCL-91.2))*exp(eta.cl) V1 ~ 4.8*exp(eta.v1) Q ~ (3.46+0.0593*(WT-75.1))*exp(eta.q); V2 ~ 1.93*(3.13+0.0458*(WT-75.1))*exp(eta.v2) A1 ~ centr; A2 ~ peri; d/dt(centr) &lt;- - A1*(CL/V1 + Q/V1) + A2*Q/V2; d/dt(peri) &lt;- A1*Q/V1 - A2*Q/V2; DV = centr / V1 * (1 + prop.err) }) } 12.4.2 Simulating Covariates This simulation correlates age, sex, and weight. Since we will be using weight based dosing, this needs to be simulated first set.seed(42) rxSetSeed(42) library(dplyr) nsub=30 ### Simulate Weight based on age and gender AGE&lt;-round(runif(nsub,min=18,max=70)) SEX&lt;-round(runif(nsub,min=0,max=1)) HTm&lt;-round(rnorm(nsub,176.3,0.17*sqrt(4482)),digits=1) HTf&lt;-round(rnorm(nsub,162.2,0.16*sqrt(4857)),digits=1) WTm&lt;-round(exp(3.28+1.92*log(HTm/100))*exp(rnorm(nsub,0,0.14)),digits=1) WTf&lt;-round(exp(3.49+1.45*log(HTf/100))*exp(rnorm(nsub,0,0.17)),digits=1) WT&lt;-ifelse(SEX==1,WTf,WTm) CRCL&lt;-round(runif(nsub,30,140)) ## id is in lower case to match the event table cov.df &lt;- tibble(id=seq_along(AGE), AGE=AGE, SEX=SEX, WT=WT, CRCL=CRCL) print(cov.df) #&gt; # A tibble: 30 x 5 #&gt; id AGE SEX WT CRCL #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 66 1 49.4 83 #&gt; 2 2 67 1 52.5 79 #&gt; 3 3 33 0 97.9 37 #&gt; 4 4 61 1 63.8 66 #&gt; 5 5 51 0 71.8 127 #&gt; 6 6 45 1 69.6 132 #&gt; 7 7 56 0 61 73 #&gt; 8 8 25 0 57.7 47 #&gt; 9 9 52 1 58.7 65 #&gt; 10 10 55 1 73.1 64 #&gt; # i 20 more rows 12.4.3 Creating weight based event table s&lt;-c(0,0.25,0.5,0.75,1,1.5,seq(2,24,by=1)) s &lt;- lapply(s, function(x){.x &lt;- 0.1 * x; c(x - .x, x + .x)}) e &lt;- et() %&gt;% ## Specify the id and weight based dosing from covariate data.frame ## This requires rxode2 XXX et(id=cov.df$id, amt=6*cov.df$WT, rate=6 * cov.df$WT) %&gt;% ## Sampling is added for each ID et(s) %&gt;% as.data.frame %&gt;% ## Merge the event table with the covarite information merge(cov.df, by=&quot;id&quot;) %&gt;% as_tibble e #&gt; # A tibble: 900 x 12 #&gt; id low time high cmt amt rate evid AGE SEX WT CRCL #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0 0 0 (obs) NA NA 0 66 1 49.4 83 #&gt; 2 1 NA 0 NA (default) 296. 296. 1 66 1 49.4 83 #&gt; 3 1 0.225 0.246 0.275 (obs) NA NA 0 66 1 49.4 83 #&gt; 4 1 0.45 0.516 0.55 (obs) NA NA 0 66 1 49.4 83 #&gt; 5 1 0.675 0.729 0.825 (obs) NA NA 0 66 1 49.4 83 #&gt; 6 1 0.9 0.921 1.1 (obs) NA NA 0 66 1 49.4 83 #&gt; 7 1 1.35 1.42 1.65 (obs) NA NA 0 66 1 49.4 83 #&gt; 8 1 1.8 1.82 2.2 (obs) NA NA 0 66 1 49.4 83 #&gt; 9 1 2.7 2.97 3.3 (obs) NA NA 0 66 1 49.4 83 #&gt; 10 1 3.6 3.87 4.4 (obs) NA NA 0 66 1 49.4 83 #&gt; # i 890 more rows 12.4.4 Solving Daptomycin simulation data &lt;- rxSolve(m1, e, ## Lotri uses lower-triangular matrix rep. for named matrix omega=lotri(eta.cl ~ .306, eta.q ~0.0652, eta.v1 ~.567, eta.v2 ~ .191), sigma=lotri(prop.err ~ 0.15), addDosing = TRUE, addCov = TRUE) #&gt; using C compiler: ‘gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’ print(data) #&gt; -- Solved rxode2 object -- #&gt; -- Parameters ($params): -- #&gt; # A tibble: 30 x 5 #&gt; id eta.cl eta.v1 eta.q eta.v2 #&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 -0.852 0.158 0.00529 0.0100 #&gt; 2 2 -0.444 -1.09 -0.374 -0.296 #&gt; 3 3 0.930 0.553 0.0127 -0.446 #&gt; 4 4 -0.813 0.0732 -0.230 0.211 #&gt; 5 5 0.219 0.175 -0.0883 -0.122 #&gt; 6 6 -0.875 -0.0607 0.0823 0.541 #&gt; 7 7 -0.463 0.611 0.613 -0.630 #&gt; 8 8 0.0513 0.167 -0.0800 -0.892 #&gt; 9 9 0.220 -1.02 0.312 0.481 #&gt; 10 10 0.00477 0.547 -0.216 -0.482 #&gt; # i 20 more rows #&gt; -- Initial Conditions ($inits): -- #&gt; centr peri #&gt; 0 0 #&gt; -- First part of data (object): -- #&gt; # A tibble: 900 x 12 #&gt; id evid cmt amt rate time DV centr peri SEX WT CRCL #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 1 296. 296. 0 0 0 0 1 49.4 83 #&gt; 2 1 0 NA NA NA 0 0 0 0 1 49.4 83 #&gt; 3 1 0 NA NA NA 0.246 20.0 69.7 2.89 1 49.4 83 #&gt; 4 1 0 NA NA NA 0.516 25.3 139. 11.7 1 49.4 83 #&gt; 5 1 0 NA NA NA 0.729 19.4 191. 22.1 1 49.4 83 #&gt; 6 1 0 NA NA NA 0.921 38.3 234. 33.5 1 49.4 83 #&gt; # i 894 more rows plot(data, log=&quot;y&quot;) #&gt; Warning in self$trans$transform(x): NaNs produced #&gt; Warning: Transformation introduced infinite values in continuous y-axis 12.4.5 Daptomycin Reference This weight-based simulation is adapted from the Daptomycin article below: Dvorchik B, Arbeit RD, Chung J, Liu S, Knebel W, Kastrissios H. Population pharmacokinetics of daptomycin. Antimicrob Agents Che mother 2004; 48: 2799-2807. doi:(10.1128/AAC.48.8.2799-2807.2004)[https://dx.doi.org/10.1128%2FAAC.48.8.2799-2807.2004] This simulation example was made available from the work of Sherwin Sy with modifications by Matthew Fidler 12.5 Inter-occasion and other nesting examples More than one level of nesting is possible in rxode2; In this example we will be using the following uncertainties and sources of variability: Level Variable Matrix specified Integrated Matrix Model uncertainty NA thetaMat thetaMat Investigator inv.Cl, inv.Ka omega theta Subject eta.Cl, eta.Ka omega omega Eye eye.Cl, eye.Ka omega omega Occasion iov.Cl, occ.Ka omega omega Unexplained Concentration prop.sd sigma sigma Unexplained Effect add.sd sigma sigma 12.5.1 Event table This event table contains nesting variables: inv: investigator id id: subject id eye: eye id (left or right) occ: occasion library(rxode2) library(dplyr) et(amountUnits=&quot;mg&quot;, timeUnits=&quot;hours&quot;) %&gt;% et(amt=10000, addl=9,ii=12,cmt=&quot;depot&quot;) %&gt;% et(time=120, amt=2000, addl=4, ii=14, cmt=&quot;depot&quot;) %&gt;% et(seq(0, 240, by=4)) %&gt;% # Assumes sampling when there is no dosing information et(seq(0, 240, by=4) + 0.1) %&gt;% ## adds 0.1 for separate eye et(id=1:20) %&gt;% ## Add an occasion per dose mutate(occ=cumsum(!is.na(amt))) %&gt;% mutate(occ=ifelse(occ == 0, 1, occ)) %&gt;% mutate(occ=2- occ %% 2) %&gt;% mutate(eye=ifelse(round(time) == time, 1, 2)) %&gt;% mutate(inv=ifelse(id &lt; 10, 1, 2)) %&gt;% as_tibble -&gt; ev 12.5.2 rxode2 model This creates the rxode2 model with multi-level nesting. Note the variables inv.Cl, inv.Ka, eta.Cl etc; You only need one variable for each level of nesting. mod &lt;- rxode2({ ## Clearance with individuals eff(0) = 1 C2 = centr/V2*(1+prop.sd) C3 = peri/V3 CL = TCl*exp(eta.Cl + eye.Cl + iov.Cl + inv.Cl) KA = TKA * exp(eta.Ka + eye.Ka + iov.Cl + inv.Ka) d/dt(depot) =-KA*depot d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3 d/dt(peri) = Q*C2 - Q*C3 d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff ef0 = eff + add.sd }) #&gt; using C compiler: ‘gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’ 12.5.3 Uncertainty in Model parameters theta &lt;- c(&quot;TKA&quot;=0.294, &quot;TCl&quot;=18.6, &quot;V2&quot;=40.2, &quot;Q&quot;=10.5, &quot;V3&quot;=297, &quot;Kin&quot;=1, &quot;Kout&quot;=1, &quot;EC50&quot;=200) ## Creating covariance matrix tmp &lt;- matrix(rnorm(8^2), 8, 8) tMat &lt;- tcrossprod(tmp, tmp) / (8 ^ 2) dimnames(tMat) &lt;- list(names(theta), names(theta)) tMat #&gt; TKA TCl V2 Q V3 #&gt; TKA 1.408151e-01 0.08277499 0.0180178917 -0.0470325576 0.029172564 #&gt; TCl 8.277499e-02 0.18104452 -0.0532724661 -0.0421074920 0.068093695 #&gt; V2 1.801789e-02 -0.05327247 0.0581816756 0.0001167516 0.006496495 #&gt; Q -4.703256e-02 -0.04210749 0.0001167516 0.1549374667 0.020764042 #&gt; V3 2.917256e-02 0.06809370 0.0064964951 0.0207640421 0.118986685 #&gt; Kin -3.445136e-02 0.01464937 -0.0426405263 0.1503174753 -0.039702872 #&gt; Kout -2.904363e-02 -0.04914350 0.0324790929 0.0069332072 0.030349396 #&gt; EC50 -4.017336e-05 0.02850637 -0.0326094799 -0.0489119232 -0.029606732 #&gt; Kin Kout EC50 #&gt; TKA -0.034451357 -0.029043632 -4.017336e-05 #&gt; TCl 0.014649373 -0.049143503 2.850637e-02 #&gt; V2 -0.042640526 0.032479093 -3.260948e-02 #&gt; Q 0.150317475 0.006933207 -4.891192e-02 #&gt; V3 -0.039702872 0.030349396 -2.960673e-02 #&gt; Kin 0.299597107 -0.074421154 -6.528526e-03 #&gt; Kout -0.074421154 0.061039604 -2.800741e-02 #&gt; EC50 -0.006528526 -0.028007407 4.167429e-02 12.5.4 Nesting Variability To specify multiple levels of nesting, you can specify it as a nested lotri matrix; When using this approach you use the condition operator | to specify what variable nesting occurs on; For the Bayesian simulation we need to specify how much information we have for each parameter; For rxode2 this is the nu parameter. In this case: - id, nu=100 or the model came from 100 subjects - eye, nu=200 or the model came from 200 eyes - occ, nu=200 or the model came from 200 occasions - inv, nu=10 or the model came from 10 investigators To specify this in lotri you can use | var(nu=X), or: omega &lt;- lotri(lotri(eta.Cl ~ 0.1, eta.Ka ~ 0.1) | id(nu=100), lotri(eye.Cl ~ 0.05, eye.Ka ~ 0.05) | eye(nu=200), lotri(iov.Cl ~ 0.01, iov.Ka ~ 0.01) | occ(nu=200), lotri(inv.Cl ~ 0.02, inv.Ka ~ 0.02) | inv(nu=10)) omega #&gt; $id #&gt; eta.Cl eta.Ka #&gt; eta.Cl 0.1 0.0 #&gt; eta.Ka 0.0 0.1 #&gt; #&gt; $eye #&gt; eye.Cl eye.Ka #&gt; eye.Cl 0.05 0.00 #&gt; eye.Ka 0.00 0.05 #&gt; #&gt; $occ #&gt; iov.Cl iov.Ka #&gt; iov.Cl 0.01 0.00 #&gt; iov.Ka 0.00 0.01 #&gt; #&gt; $inv #&gt; inv.Cl inv.Ka #&gt; inv.Cl 0.02 0.00 #&gt; inv.Ka 0.00 0.02 #&gt; #&gt; Properties: nu 12.5.5 Unexplained variability The last piece of variability to specify is the unexplained variability sigma &lt;- lotri(prop.sd ~ .25, add.sd~ 0.125) 12.5.6 Solving the problem s &lt;- rxSolve(mod, theta, ev, thetaMat=tMat, omega=omega, sigma=sigma, sigmaDf=400, nStud=400) #&gt; using C compiler: ‘gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’ #&gt; unhandled error message: EE:[lsoda] 70000 steps taken before reaching tout #&gt; @(lsoda.c:750 #&gt; Warning: some ID(s) could not solve the ODEs correctly; These values are #&gt; replaced with &#39;NA&#39; print(s) #&gt; -- Solved rxode2 object -- #&gt; -- Parameters ($params): -- #&gt; # A tibble: 8,000 x 24 #&gt; sim.id id `inv.Cl(inv==1)` `inv.Cl(inv==2)` `inv.Ka(inv==1)` #&gt; &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 0.251 0.0765 -0.0741 #&gt; 2 1 2 0.251 0.0765 -0.0741 #&gt; 3 1 3 0.251 0.0765 -0.0741 #&gt; 4 1 4 0.251 0.0765 -0.0741 #&gt; 5 1 5 0.251 0.0765 -0.0741 #&gt; 6 1 6 0.251 0.0765 -0.0741 #&gt; 7 1 7 0.251 0.0765 -0.0741 #&gt; 8 1 8 0.251 0.0765 -0.0741 #&gt; 9 1 9 0.251 0.0765 -0.0741 #&gt; 10 1 10 0.251 0.0765 -0.0741 #&gt; # i 7,990 more rows #&gt; # i 19 more variables: `inv.Ka(inv==2)` &lt;dbl&gt;, `eye.Cl(eye==1)` &lt;dbl&gt;, #&gt; # `eye.Cl(eye==2)` &lt;dbl&gt;, `eye.Ka(eye==1)` &lt;dbl&gt;, `eye.Ka(eye==2)` &lt;dbl&gt;, #&gt; # `iov.Cl(occ==1)` &lt;dbl&gt;, `iov.Cl(occ==2)` &lt;dbl&gt;, `iov.Ka(occ==1)` &lt;dbl&gt;, #&gt; # `iov.Ka(occ==2)` &lt;dbl&gt;, V2 &lt;dbl&gt;, V3 &lt;dbl&gt;, TCl &lt;dbl&gt;, eta.Cl &lt;dbl&gt;, #&gt; # TKA &lt;dbl&gt;, eta.Ka &lt;dbl&gt;, Q &lt;dbl&gt;, Kin &lt;dbl&gt;, Kout &lt;dbl&gt;, EC50 &lt;dbl&gt; #&gt; -- Initial Conditions ($inits): -- #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; #&gt; Simulation with uncertainty in: #&gt; * parameters ($thetaMat for changes) #&gt; * omega matrix ($omegaList) #&gt; #&gt; -- First part of data (object): -- #&gt; # A tibble: 976,000 x 21 #&gt; sim.id id time inv.Cl inv.Ka eye.Cl eye.Ka iov.Cl iov.Ka C2 C3 #&gt; &lt;int&gt; &lt;int&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 0 0.251 -0.0741 0.0127 -0.156 -0.00963 0.0813 0 0 #&gt; 2 1 1 0.1 0.251 -0.0741 0.122 -0.0143 -0.00963 0.0813 13.5 0.0159 #&gt; 3 1 1 4 0.251 -0.0741 0.0127 -0.156 -0.00963 0.0813 2.36 3.80 #&gt; 4 1 1 4.1 0.251 -0.0741 0.122 -0.0143 -0.00963 0.0813 8.16 3.84 #&gt; 5 1 1 8 0.251 -0.0741 0.0127 -0.156 -0.00963 0.0813 0.392 4.26 #&gt; 6 1 1 8.1 0.251 -0.0741 0.122 -0.0143 -0.00963 0.0813 0.728 4.25 #&gt; # i 975,994 more rows #&gt; # i 10 more variables: CL &lt;dbl&gt;, KA &lt;dbl&gt;, ef0 &lt;dbl&gt;, depot &lt;dbl&gt;, centr &lt;dbl&gt;, #&gt; # peri &lt;dbl&gt;, eff &lt;dbl&gt;, occ &lt;fct&gt;, eye &lt;fct&gt;, inv &lt;fct&gt; There are multiple investigators in a study; Each investigator has a number of individuals enrolled at their site. rxode2 automatically determines the number of investigators and then will simulate an effect for each investigator. With the output, inv.Cl(inv==1) will be the inv.Cl for investigator 1, inv.Cl(inv==2) will be the inv.Cl for investigator 2, etc. inv.Cl(inv==1), inv.Cl(inv==2), etc will be simulated for each study and then combined to form the between investigator variability. In equation form these represent the following: inv.Cl = (inv == 1) * `inv.Cl(inv==1)` + (inv == 2) * `inv.Cl(inv==2)` If you look at the simulated parameters you can see inv.Cl(inv==1) and inv.Cl(inv==2) are in the s$params; They are the same for each study: print(head(s$params)) #&gt; sim.id id inv.Cl(inv==1) inv.Cl(inv==2) inv.Ka(inv==1) inv.Ka(inv==2) #&gt; 1 1 1 0.2511322 0.07650072 -0.07407926 0.02202168 #&gt; 2 1 2 0.2511322 0.07650072 -0.07407926 0.02202168 #&gt; 3 1 3 0.2511322 0.07650072 -0.07407926 0.02202168 #&gt; 4 1 4 0.2511322 0.07650072 -0.07407926 0.02202168 #&gt; 5 1 5 0.2511322 0.07650072 -0.07407926 0.02202168 #&gt; 6 1 6 0.2511322 0.07650072 -0.07407926 0.02202168 #&gt; eye.Cl(eye==1) eye.Cl(eye==2) eye.Ka(eye==1) eye.Ka(eye==2) iov.Cl(occ==1) #&gt; 1 0.01270627 0.12170298 -0.15645931 -0.01431089 -0.009629471 #&gt; 2 -0.17730664 0.03257883 0.32307021 0.02920050 -0.174327268 #&gt; 3 0.11662407 0.23070953 0.14031942 0.60774555 0.108968491 #&gt; 4 0.15094002 -0.06667588 0.14962819 0.06226514 -0.043479003 #&gt; 5 -0.03450830 0.18531423 -0.52570577 -0.14201201 -0.062005657 #&gt; 6 -0.35488059 0.58910822 -0.05440263 0.01390173 -0.032395527 #&gt; iov.Cl(occ==2) iov.Ka(occ==1) iov.Ka(occ==2) V2 V3 TCl #&gt; 1 0.01053195 0.081266104 -0.07738340 39.89608 296.4477 18.66578 #&gt; 2 0.14111236 0.012959501 0.14003903 39.89608 296.4477 18.66578 #&gt; 3 -0.08081801 0.064904438 -0.05309035 39.89608 296.4477 18.66578 #&gt; 4 -0.02781613 0.021622026 -0.17969560 39.89608 296.4477 18.66578 #&gt; 5 0.14666663 -0.032748073 -0.02417555 39.89608 296.4477 18.66578 #&gt; 6 -0.02895152 0.002390472 0.05844429 39.89608 296.4477 18.66578 #&gt; eta.Cl TKA eta.Ka Q Kin Kout EC50 #&gt; 1 0.6985427 0.346799 0.42017137 9.659552 0.03348837 0.9102127 200.427 #&gt; 2 -0.1405521 0.346799 -0.17769437 9.659552 0.03348837 0.9102127 200.427 #&gt; 3 0.2575912 0.346799 0.22284272 9.659552 0.03348837 0.9102127 200.427 #&gt; 4 0.4722423 0.346799 0.49685712 9.659552 0.03348837 0.9102127 200.427 #&gt; 5 -0.1505078 0.346799 -0.43312621 9.659552 0.03348837 0.9102127 200.427 #&gt; 6 -0.1271020 0.346799 0.08195574 9.659552 0.03348837 0.9102127 200.427 print(head(s$params %&gt;% filter(sim.id == 2))) #&gt; sim.id id inv.Cl(inv==1) inv.Cl(inv==2) inv.Ka(inv==1) inv.Ka(inv==2) #&gt; 1 2 1 0.1093052 -0.0673165 0.1186236 -0.08942504 #&gt; 2 2 2 0.1093052 -0.0673165 0.1186236 -0.08942504 #&gt; 3 2 3 0.1093052 -0.0673165 0.1186236 -0.08942504 #&gt; 4 2 4 0.1093052 -0.0673165 0.1186236 -0.08942504 #&gt; 5 2 5 0.1093052 -0.0673165 0.1186236 -0.08942504 #&gt; 6 2 6 0.1093052 -0.0673165 0.1186236 -0.08942504 #&gt; eye.Cl(eye==1) eye.Cl(eye==2) eye.Ka(eye==1) eye.Ka(eye==2) iov.Cl(occ==1) #&gt; 1 0.35152729 0.006594725 -0.06268297 0.29815635 -0.00881754 #&gt; 2 0.10269092 0.146594486 -0.20490974 0.28538009 -0.07747854 #&gt; 3 -0.63206970 0.346871624 0.06642099 0.35270304 -0.06741916 #&gt; 4 -0.08415895 0.235107634 0.12953250 -0.17707732 0.06017794 #&gt; 5 0.33726812 0.072669926 -0.05740940 -0.08718347 -0.09088558 #&gt; 6 -0.26619889 -0.007725891 -0.18858394 -0.15278522 0.14865110 #&gt; iov.Cl(occ==2) iov.Ka(occ==1) iov.Ka(occ==2) V2 V3 TCl #&gt; 1 0.015905350 -0.02096693 -0.12871823 39.95281 297.0105 18.48517 #&gt; 2 0.021713327 0.10111395 -0.04911822 39.95281 297.0105 18.48517 #&gt; 3 -0.027550757 -0.08063562 0.07982127 39.95281 297.0105 18.48517 #&gt; 4 -0.019521504 0.06468350 0.08335715 39.95281 297.0105 18.48517 #&gt; 5 -0.003415422 -0.03601159 0.04816064 39.95281 297.0105 18.48517 #&gt; 6 -0.053526809 -0.16281362 0.01215932 39.95281 297.0105 18.48517 #&gt; eta.Cl TKA eta.Ka Q Kin Kout EC50 #&gt; 1 -0.35476449 -0.1722565 0.21079536 10.89209 1.256925 0.9366159 199.9913 #&gt; 2 -0.17388248 -0.1722565 0.62943162 10.89209 1.256925 0.9366159 199.9913 #&gt; 3 0.90160059 -0.1722565 0.08201732 10.89209 1.256925 0.9366159 199.9913 #&gt; 4 0.10391092 -0.1722565 0.38871734 10.89209 1.256925 0.9366159 199.9913 #&gt; 5 0.28247914 -0.1722565 -0.14271404 10.89209 1.256925 0.9366159 199.9913 #&gt; 6 -0.02269591 -0.1722565 0.29263333 10.89209 1.256925 0.9366159 199.9913 For between eye variability and between occasion variability each individual simulates a number of variables that become the between eye and between occasion variability; In the case of the eye: eye.Cl = (eye == 1) * `eye.Cl(eye==1)` + (eye == 2) * `eye.Cl(eye==2)` So when you look the simulation each of these variables (ie eye.Cl(eye==1), eye.Cl(eye==2), etc) they change for each individual and when combined make the between eye variability or the between occasion variability that can be seen in some pharamcometric models. 12.6 Transit compartment models Savic 2008 first introduced the idea of transit compartments being a mechanistic explanation of a a lag-time type phenomena. rxode2 has special handling of these models: You can specify this in a similar manner as the original paper: library(rxode2) mod &lt;- function() { model({ ## Table 3 from Savic 2007 cl = 17.2 # (L/hr) vc = 45.1 # L ka = 0.38 # 1/hr mtt = 0.37 # hr bio=1 n = 20.1 k = cl/vc ktr = (n+1)/mtt ## note that lgammafn is the same as lgamma in R. d/dt(depot) = exp(log(bio*podo(depot))+log(ktr)+n*log(ktr*tad(depot))- ktr*tad(depot)-lgammafn(n+1))-ka*depot d/dt(cen) = ka*depot-k*cen }) } et &lt;- et(0, 7, length.out=200) %&gt;% et(amt=20, time=0, evid=7) transit &lt;- rxSolve(mod, et) #&gt; using C compiler: ‘gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’ plot(transit, cen, ylab=&quot;Central Concentration&quot;) Another option is to specify the transit compartment function transit syntax. This specifies the parameters transit(number of transit compartments, mean transit time, bioavailability). The bioavailability term is optional. The same model can be specified by: mod &lt;- function() { ini({ ## Table 3 from Savic 2007 cl &lt;- 17.2 # (L/hr) vc &lt;- 45.1 # L ka &lt;- 0.38 # 1/hr mtt &lt;- 0.37 # hr bio &lt;- 1 n &lt;- 20.1 }) model({ k &lt;- cl/vc ktr &lt;- (n+1)/mtt d/dt(depot) &lt;- transit(n,mtt,bio)-ka*depot d/dt(cen) &lt;- ka*depot-k*cen }) } et &lt;- et(0, 7, length.out=200) %&gt;% et(amt=20, evid=7) transit &lt;- rxSolve(mod, et) #&gt; i parameter labels from comments will be replaced by &#39;label()&#39; #&gt; using C compiler: ‘gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’ plot(transit, cen, ylab=&quot;Central Concentration&quot;) A couple of things to keep in mind when using this approach: This approach implicitly assumes that the absorption through the transit compartment is completed before the next dose begins Different types of doses (ie bolus/infusion) to the compartment affect the time after dose calculation (tad) which is used in the transit compartment calculation. These (therefore) are not currently supported. The most stable way is to use tad(cmt) and podo(cmt), this way doses to other compartments do not affect the transit compartment calculation. Internally, the transit syntax uses either the currently defined cmt d/dt(cmt)=transit(...), or cmt. If the transit compartment is used outside of a d/dt() (not recommended), the cmt that is used is the last d/dt(cmt) defined it the model. This also means compartments do not affect one another (ie a oral, transit compartment drug dosed immediately with an IV infusion) "],["advanced-miscellaneous-topics.html", "Chapter 13 Advanced &amp; Miscellaneous Topics 13.1 Covariates in rxode2 13.2 Shiny and rxode2 13.3 Using rxode2 with a pipeline 13.4 Speeding up rxode2 13.5 Integrating rxode2 models in your package 13.6 Stiff ODEs with Jacobian Specification", " Chapter 13 Advanced &amp; Miscellaneous Topics This covers advanced or miscellaneous topics in rxode2 13.1 Covariates in rxode2 13.1.1 Individual Covariates If there is an individual covariate you wish to solve for you may specify it by the iCov dataset: library(rxode2) library(units) library(xgxr) mod3 &lt;- function() { ini({ TKA &lt;- 2.94E-01 #### Clearance with individuals TCL &lt;- 1.86E+01 TV2 &lt;-4.02E+01 TQ &lt;-1.05E+01 TV3 &lt;-2.97E+02 TKin &lt;- 1 TKout &lt;- 1 TEC50 &lt;-200 }) model({ KA &lt;- TKA CL &lt;- TCL * (WT / 70) ^ 0.75 V2 &lt;- TV2 Q &lt;- TQ V3 &lt;- TV3 Kin &lt;- TKin Kout &lt;- TKout EC50 &lt;- TEC50 Tz &lt;- 8 amp &lt;- 0.1 C2 &lt;- central/V2 C3 &lt;- peri/V3 d/dt(depot) &lt;- -KA*depot d/dt(central) &lt;- KA*depot - CL*C2 - Q*C2 + Q*C3 d/dt(peri) &lt;- Q*C2 - Q*C3 d/dt(eff) &lt;- Kin - Kout*(1-C2/(EC50+C2))*eff eff(0) &lt;- 1 ## This specifies that the effect compartment starts at 1. }) } ev &lt;- et(amount.units=&quot;mg&quot;, time.units=&quot;hours&quot;) %&gt;% et(amt=10000, cmt=1) %&gt;% et(0,48,length.out=100) %&gt;% et(id=1:4) set.seed(10) rxSetSeed(10) #### Now use iCov to simulate a 4-id sample r1 &lt;- solve(mod3, ev, ### Create individual covariate data-frame iCov=data.frame(id=1:4, WT=rnorm(4, 70, 10))) #&gt; using C compiler: ‘gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’ print(r1) #&gt; -- Solved rxode2 object -- #&gt; -- Parameters ($params): -- #&gt; TKA TCL TV2 TQ TV3 TKin TKout TEC50 Tz amp #&gt; 0.294 18.600 40.200 10.500 297.000 1.000 1.000 200.000 8.000 0.100 #&gt; -- Initial Conditions ($inits): -- #&gt; depot central peri eff #&gt; 0 0 0 1 #&gt; -- First part of data (object): -- #&gt; # A tibble: 400 x 17 #&gt; id time KA CL V2 Q V3 Kin Kout EC50 C2 C3 depot #&gt; &lt;int&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0 0.294 18.6 40.2 10.5 297 1 1 200 0 0 10000 #&gt; 2 1 0.485 0.294 18.6 40.2 10.5 297 1 1 200 27.8 0.257 8671. #&gt; 3 1 0.970 0.294 18.6 40.2 10.5 297 1 1 200 43.7 0.873 7519. #&gt; 4 1 1.45 0.294 18.6 40.2 10.5 297 1 1 200 51.7 1.68 6520. #&gt; 5 1 1.94 0.294 18.6 40.2 10.5 297 1 1 200 54.7 2.56 5654. #&gt; 6 1 2.42 0.294 18.6 40.2 10.5 297 1 1 200 54.5 3.45 4903. #&gt; # i 394 more rows #&gt; # i 4 more variables: central &lt;dbl&gt;, peri &lt;dbl&gt;, eff &lt;dbl&gt;, WT &lt;dbl&gt; plot(r1, C2, log=&quot;y&quot;) #&gt; Warning: Transformation introduced infinite values in continuous y-axis 13.1.2 Time Varying Covariates Covariates are easy to specify in rxode2, you can specify them as a variable. Time-varying covariates, like clock time in a circadian rhythm model, can also be used. Extending the indirect response model already discussed, we have: library(rxode2) library(units) mod4 &lt;- mod3 %&gt;% model(d/dt(eff) &lt;- Kin - Kout*(1-C2/(EC50+C2))*eff) %&gt;% model(-Kin) %&gt;% model(Kin &lt;- TKin + amp *cos(2*pi*(ctime-Tz)/24), append=C2, cov=&quot;ctime&quot;) ev &lt;- et(amountUnits=&quot;mg&quot;, timeUnits=&quot;hours&quot;) %&gt;% et(amt=10000, cmt=1) %&gt;% et(0,48,length.out=100) #### Create data frame of 8 am dosing for the first dose This is done #### with base R but it can be done with dplyr or data.table ev$ctime &lt;- (ev$time+set_units(8,hr)) %% 24 ev$WT &lt;- 70 Now there is a covariate present in the event dataset, the system can be solved by combining the dataset and the model: r1 &lt;- solve(mod4, ev, covsInterpolation=&quot;linear&quot;) print(r1) #&gt; -- Solved rxode2 object -- #&gt; -- Parameters ($params): -- #&gt; TKA TCL TV2 TQ TV3 TKout TEC50 #&gt; 0.294000 18.600000 40.200000 10.500000 297.000000 1.000000 200.000000 #&gt; TKin Tz amp pi #&gt; 1.000000 8.000000 0.100000 3.141593 #&gt; -- Initial Conditions ($inits): -- #&gt; depot central peri eff #&gt; 0 0 0 1 #&gt; -- First part of data (object): -- #&gt; # A tibble: 100 x 17 #&gt; time KA CL V2 Q V3 Kout EC50 C2 Kin C3 depot #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0.294 18.6 40.2 10.5 297 1 200 0 1.1 0 10000 #&gt; 2 0.485 0.294 18.6 40.2 10.5 297 1 200 27.8 1.10 0.257 8671. #&gt; 3 0.970 0.294 18.6 40.2 10.5 297 1 200 43.7 1.10 0.874 7519. #&gt; 4 1.45 0.294 18.6 40.2 10.5 297 1 200 51.8 1.09 1.68 6520. #&gt; 5 1.94 0.294 18.6 40.2 10.5 297 1 200 54.8 1.09 2.56 5654. #&gt; 6 2.42 0.294 18.6 40.2 10.5 297 1 200 54.6 1.08 3.45 4903. #&gt; # i 94 more rows #&gt; # i 5 more variables: central &lt;dbl&gt;, peri &lt;dbl&gt;, eff &lt;dbl&gt;, ctime [h], WT &lt;dbl&gt; When solving ODE equations, the solver may sample times outside of the data. When this happens, this ODE solver can use linear interpolation between the covariate values. It is equivalent to R’s approxfun with method=\"linear\". plot(r1,C2, ylab=&quot;Central Concentration&quot;) plot(r1,eff) + ylab(&quot;Effect&quot;) + xlab(&quot;Time&quot;) Note that the linear approximation in this case leads to some kinks in the solved system at 24-hours where the covariate has a linear interpolation between near 24 and near 0. While linear seems reasonable, cases like clock time make other interpolation methods more attractive. In rxode2 the default covariate interpolation is be the last observation carried forward (locf), or constant approximation. This is equivalent to R’s approxfun with method=\"constant\". r1 &lt;- solve(mod4, ev,covsInterpolation=&quot;locf&quot;) print(r1) #&gt; -- Solved rxode2 object -- #&gt; -- Parameters ($params): -- #&gt; TKA TCL TV2 TQ TV3 TKout TEC50 #&gt; 0.294000 18.600000 40.200000 10.500000 297.000000 1.000000 200.000000 #&gt; TKin Tz amp pi #&gt; 1.000000 8.000000 0.100000 3.141593 #&gt; -- Initial Conditions ($inits): -- #&gt; depot central peri eff #&gt; 0 0 0 1 #&gt; -- First part of data (object): -- #&gt; # A tibble: 100 x 17 #&gt; time KA CL V2 Q V3 Kout EC50 C2 Kin C3 depot #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0.294 18.6 40.2 10.5 297 1 200 0 1.1 0 10000 #&gt; 2 0.485 0.294 18.6 40.2 10.5 297 1 200 27.8 1.10 0.257 8671. #&gt; 3 0.970 0.294 18.6 40.2 10.5 297 1 200 43.7 1.10 0.874 7519. #&gt; 4 1.45 0.294 18.6 40.2 10.5 297 1 200 51.8 1.09 1.68 6520. #&gt; 5 1.94 0.294 18.6 40.2 10.5 297 1 200 54.8 1.09 2.56 5654. #&gt; 6 2.42 0.294 18.6 40.2 10.5 297 1 200 54.6 1.08 3.45 4903. #&gt; # i 94 more rows #&gt; # i 5 more variables: central &lt;dbl&gt;, peri &lt;dbl&gt;, eff &lt;dbl&gt;, ctime [h], WT &lt;dbl&gt; which gives the following plots: plot(r1,C2, ylab=&quot;Central Concentration&quot;, xlab=&quot;Time&quot;) plot(r1,eff, ylab=&quot;Effect&quot;, xlab=&quot;Time&quot;) In this case, the plots seem to be smoother. You can also use NONMEM’s preferred interpolation style of next observation carried backward (NOCB): r1 &lt;- solve(mod4, ev,covsInterpolation=&quot;nocb&quot;) print(r1) #&gt; -- Solved rxode2 object -- #&gt; -- Parameters ($params): -- #&gt; TKA TCL TV2 TQ TV3 TKout TEC50 #&gt; 0.294000 18.600000 40.200000 10.500000 297.000000 1.000000 200.000000 #&gt; TKin Tz amp pi #&gt; 1.000000 8.000000 0.100000 3.141593 #&gt; -- Initial Conditions ($inits): -- #&gt; depot central peri eff #&gt; 0 0 0 1 #&gt; -- First part of data (object): -- #&gt; # A tibble: 100 x 17 #&gt; time KA CL V2 Q V3 Kout EC50 C2 Kin C3 depot #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0.294 18.6 40.2 10.5 297 1 200 0 1.1 0 10000 #&gt; 2 0.485 0.294 18.6 40.2 10.5 297 1 200 27.8 1.10 0.257 8671. #&gt; 3 0.970 0.294 18.6 40.2 10.5 297 1 200 43.7 1.10 0.874 7519. #&gt; 4 1.45 0.294 18.6 40.2 10.5 297 1 200 51.8 1.09 1.68 6520. #&gt; 5 1.94 0.294 18.6 40.2 10.5 297 1 200 54.8 1.09 2.56 5654. #&gt; 6 2.42 0.294 18.6 40.2 10.5 297 1 200 54.6 1.08 3.45 4903. #&gt; # i 94 more rows #&gt; # i 5 more variables: central &lt;dbl&gt;, peri &lt;dbl&gt;, eff &lt;dbl&gt;, ctime [h], WT &lt;dbl&gt; which gives the following plots: plot(r1,C2, ylab=&quot;Central Concentration&quot;, xlab=&quot;Time&quot;) plot(r1,eff, ylab=&quot;Effect&quot;, xlab=&quot;Time&quot;) 13.2 Shiny and rxode2 13.2.1 Facilities for generating R shiny applications An example of creating an R shiny application to interactively explore responses of various complex dosing regimens is available at http://qsp.engr.uga.edu:3838/rxode2/RegimenSimulator. Shiny applications like this one may be programmatically created with the experimental function genShinyApp.template(). The above application includes widgets for varying the dose, dosing regimen, dose cycle, and number of cycles. genShinyApp.template(appDir = &quot;shinyExample&quot;, verbose=TRUE) library(shiny) runApp(&quot;shinyExample&quot;) Click here to go to the Shiny App 13.2.2 Exploring parameter fits graphically using shiny An rxode2 object can be explored with rxShiny(obj). rxShiny() will also allow you to try new models to see how they behave. 13.3 Using rxode2 with a pipeline 13.3.1 Setting up the rxode2 model for the pipeline In this example we will show how to use rxode2 in a simple pipeline. We can start with a model that can be used for the different simulation workflows that rxode2 can handle: library(rxode2) Ribba2012 &lt;- function() { ini({ k = 100 tkde = 0.24 eta.tkde = 0 tkpq = 0.0295 eta.kpq = 0 tkqpp = 0.0031 eta.kqpp = 0 tlambdap = 0.121 eta.lambdap = 0 tgamma = 0.729 eta.gamma = 0 tdeltaqp = 0.00867 eta.deltaqp = 0 prop.sd &lt;- 0 tpt0 = 7.13 eta.pt0 = 0 tq0 = 41.2 eta.q0 = 0 }) model({ kde ~ tkde*exp(eta.tkde) kpq ~ tkpq * exp(eta.kpq) kqpp ~ tkqpp * exp(eta.kqpp) lambdap ~ tlambdap*exp(eta.lambdap) gamma ~ tgamma*exp(eta.gamma) deltaqp ~ tdeltaqp*exp(eta.deltaqp) d/dt(c) = -kde * c d/dt(pt) = lambdap * pt *(1-pstar/k) + kqpp*qp - kpq*pt - gamma*c*kde*pt d/dt(q) = kpq*pt -gamma*c*kde*q d/dt(qp) = gamma*c*kde*q - kqpp*qp - deltaqp*qp #### initial conditions pt0 ~ tpt0*exp(eta.pt0) q0 ~ tq0*exp(eta.q0) pt(0) = pt0 q(0) = q0 pstar &lt;- (pt+q+qp) pstar ~ prop(prop.sd) }) } This is a tumor growth model described in Ribba 2012. In this case, we compiled the model into an R object Ribba2012, though in an rxode2 simulation pipeline, you do not have to assign the compiled model to any object, though I think it makes sense. 13.3.2 Simulating one event table Simulating a single event table is quite simple: You pipe the rxode2 simulation object into an event table object by et(). When the events are completely specified, you simply solve the ODE system with rxSolve(). In this case you can pipe the output to plot() to conveniently view the results. Note for the plot we are only selecting the selecting following: pt (Proliferative Tissue), q (quiescent tissue) qp (DNA-Damaged quiescent tissue) and pstar (total tumor tissue) Ribba2012 %&gt;% # Use rxode2 et(time.units=&quot;months&quot;) %&gt;% # Pipe to a new event table et(amt=1, time=50, until=58, ii=1.5) %&gt;% # Add dosing every 1.5 months et(0, 250, by=0.5) %&gt;% # Add some sampling times (not required) rxSolve() %&gt;% # Solve the simulation plot(pt, q, qp, pstar) # Plot it, plotting the variables of interest 13.3.3 Simulating multiple subjects from a single event table 13.3.3.1 Simulating with between subject variability The next sort of simulation that may be useful is simulating multiple patients with the same treatments. In this case, we will use the omega matrix specified by the paper: #### Add CVs from paper for individual simulation #### Uses exact formula: lognCv = function(x){log((x/100)^2+1)} library(lotri) #### Now create omega matrix #### I&#39;m using lotri to quickly specify names/diagonals omega &lt;- lotri(eta.pt0 ~ lognCv(94), eta.q0 ~ lognCv(54), eta.lambdap ~ lognCv(72), eta.kqp ~ lognCv(76), eta.kqpp ~ lognCv(97), eta.deltaqp ~ lognCv(115), eta.tkde ~ lognCv(70)) omega #&gt; eta.pt0 eta.q0 eta.lambdap eta.kqp eta.kqpp eta.deltaqp #&gt; eta.pt0 0.6331848 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #&gt; eta.q0 0.0000000 0.2558818 0.0000000 0.0000000 0.0000000 0.0000000 #&gt; eta.lambdap 0.0000000 0.0000000 0.4176571 0.0000000 0.0000000 0.0000000 #&gt; eta.kqp 0.0000000 0.0000000 0.0000000 0.4559047 0.0000000 0.0000000 #&gt; eta.kqpp 0.0000000 0.0000000 0.0000000 0.0000000 0.6631518 0.0000000 #&gt; eta.deltaqp 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.8426442 #&gt; eta.tkde 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #&gt; eta.tkde #&gt; eta.pt0 0.0000000 #&gt; eta.q0 0.0000000 #&gt; eta.lambdap 0.0000000 #&gt; eta.kqp 0.0000000 #&gt; eta.kqpp 0.0000000 #&gt; eta.deltaqp 0.0000000 #&gt; eta.tkde 0.3987761 With this information, it is easy to simulate 3 subjects from the model-based parameters: set.seed(1089) rxSetSeed(1089) Ribba2012 %&gt;% # Use rxode2 et(time.units=&quot;months&quot;) %&gt;% # Pipe to a new event table et(amt=1, time=50, until=58, ii=1.5) %&gt;% # Add dosing every 1.5 months et(0, 250, by=0.5) %&gt;% # Add some sampling times (not required) rxSolve(nSub=3, omega=omega) %&gt;% # Solve the simulation plot(pt, q, qp, pstar) # Plot it, plotting the variables of interest Note there are two different things that were added to this simulation: - nSub to specify how many subjects are in the model - omega to specify the between subject variability. 13.3.3.2 Simulation with unexplained variability You can even add unexplained variability quite easily: Ribba2012 %&gt;% # Use rxode2 ini(prop.sd=0.05) %&gt;% # change variability et(time.units=&quot;months&quot;) %&gt;% # Pipe to a new event table et(amt=1, time=50, until=58, ii=1.5) %&gt;% # Add dosing every 1.5 months et(0, 250, by=0.5) %&gt;% # Add some sampling times (not required) rxSolve(nSub=3, omega=omega) %&gt;% plot(pt, q, qp, sim) # Plot it, plotting the variables of interest ### note that sim is the simulated pstar since this is simulated from the ### model with a nlmixr2 endpoint In this case we only added the sigma matrix to have unexplained variability on the pstar or total tumor tissue. You can even simulate with uncertainty in the theta omega and sigma values if you wish. 13.3.3.3 Simulation with uncertainty in all the parameters (by matrices) If we assume these parameters came from 95 subjects with 8 observations apiece, the degrees of freedom for the omega matrix would be 95, and the degrees of freedom of the sigma matrix would be 95*8=760 because 95 items informed the omega matrix, and 760 items informed the sigma matrix. Ribba2012 %&gt;% # Use rxode2 ini(prop.sd = 0.05) %&gt;% et(time.units=&quot;months&quot;) %&gt;% # Pipe to a new event table et(amt=1, time=50, until=58, ii=1.5) %&gt;% # Add dosing every 1.5 months et(0, 250, by=0.5) %&gt;% # Add some sampling times (not required) rxSolve(nSub=3, nStud=3, omega=omega, dfSub=760, dfObs=95) %&gt;% # Solve the simulation plot(pt, q, qp, sim) # Plot it, plotting the variables of interest Often in simulations we have a full covariance matrix for the fixed effect parameters. In this case, we do not have the matrix, but it could be specified by thetaMat. While we do not have a full covariance matrix, we can have information about the diagonal elements of the covariance matrix from the model paper. These can be converted as follows: rseVar &lt;- function(est, rse){ return(est*rse/100)^2 } thetaMat &lt;- lotri(tpt0 ~ rseVar(7.13,25), tq0 ~ rseVar(41.2,7), tlambdap ~ rseVar(0.121, 16), tkqpp ~ rseVar(0.0031, 35), tdeltaqp ~ rseVar(0.00867, 21), tgamma ~ rseVar(0.729, 37), tkde ~ rseVar(0.24, 33) ) thetaMat #&gt; tpt0 tq0 tlambdap tkqpp tdeltaqp tgamma tkde #&gt; tpt0 1.7825 0.000 0.00000 0.000000 0.0000000 0.00000 0.0000 #&gt; tq0 0.0000 2.884 0.00000 0.000000 0.0000000 0.00000 0.0000 #&gt; tlambdap 0.0000 0.000 0.01936 0.000000 0.0000000 0.00000 0.0000 #&gt; tkqpp 0.0000 0.000 0.00000 0.001085 0.0000000 0.00000 0.0000 #&gt; tdeltaqp 0.0000 0.000 0.00000 0.000000 0.0018207 0.00000 0.0000 #&gt; tgamma 0.0000 0.000 0.00000 0.000000 0.0000000 0.26973 0.0000 #&gt; tkde 0.0000 0.000 0.00000 0.000000 0.0000000 0.00000 0.0792 Now we have a thetaMat to represent the uncertainty in the theta matrix, as well as the other pieces in the simulation. Typically you can put this information into your simulation with the thetaMat matrix. With such large variability in theta it is easy to sample a negative rate constant, which does not make sense. For example: Ribba2012 %&gt;% # Use rxode2 ini(prop.sd = 0.05) %&gt;% et(time.units=&quot;months&quot;) %&gt;% # Pipe to a new event table et(amt=1, time=50, until=58, ii=1.5) %&gt;% # Add dosing every 1.5 months et(0, 250, by=0.5) %&gt;% # Add some sampling times (not required) rxSolve(nSub=2, nStud=2, omega=omega, thetaMat=thetaMat, dfSub=760, dfObs=95) %&gt;% # Solve the simulation plot(pt, q, qp, pstar) # Plot it, plotting the variables of interest #&gt; ℹ change initial estimate of `prop.sd` to `0.05` #&gt; unhandled error message: EE:[lsoda] 70000 steps taken before reaching tout #&gt; @(lsoda.c:750 #&gt; Warning message: #&gt; In rxSolve_(object, .ctl, .nms, .xtra, params, events, inits, setupOnly = .setupOnly) : #&gt; Some ID(s) could not solve the ODEs correctly; These values are replaced with NA. To correct these problems you simply need to use a truncated multivariate normal and specify the reasonable ranges for the parameters. For theta this is specified by thetaLower and thetaUpper. Similar parameters are there for the other matrices: omegaLower, omegaUpper, sigmaLower and sigmaUpper. These may be named vectors, one numeric value, or a numeric vector matching the number of parameters specified in the thetaMat matrix. In this case the simulation simply has to be modified to have thetaLower=0 to make sure all rates are positive: Ribba2012 %&gt;% # Use rxode2 ini(prop.sd = 0.05) %&gt;% et(time.units=&quot;months&quot;) %&gt;% # Pipe to a new event table et(amt=1, time=50, until=58, ii=1.5) %&gt;% # Add dosing every 1.5 months et(0, 250, by=0.5) %&gt;% # Add some sampling times (not required) rxSolve(nSub=2, nStud=2, omega=omega, thetaMat=thetaMat, thetaLower=0, # Make sure the rates are reasonable dfSub=760, dfObs=95) %&gt;% # Solve the simulation plot(pt, q, qp, sim) # Plot it, plotting the variables of interest 13.3.4 Summarizing the simulation output While it is easy to use dplyr and data.table to perform your own summary of simulations, rxode2 also provides this ability by the confint function. #### This takes a little more time; Most of the time is the summary #### time. sim0 &lt;- Ribba2012 %&gt;% # Use rxode2 ini(prop.sd=0.05) %&gt;% et(time.units=&quot;months&quot;) %&gt;% # Pipe to a new event table et(amt=1, time=50, until=58, ii=1.5) %&gt;% # Add dosing every 1.5 months et(0, 250, by=0.5) %&gt;% # Add some sampling times (not required) rxSolve(nSub=10, nStud=10, omega=omega, thetaMat=thetaMat, thetaLower=0, # Make sure the rates are reasonable dfSub=760, dfObs=95) %&gt;% # Solve the simulation confint(c(&quot;pt&quot;,&quot;q&quot;,&quot;qp&quot;,&quot;sim&quot;),level=0.90); # Create Simulation intervals sim0 %&gt;% plot() # Plot the simulation intervals 13.3.4.1 Simulating from a data-frame of parameters While the simulation from matrices can be very useful and a fast way to simulate information, sometimes you may want to simulate more complex scenarios. For instance, there may be some reason to believe that tkde needs to be above tlambdap, therefore these need to be simulated more carefully. You can generate the data frame in whatever way you want. The internal method of simulating the new parameters is exported too. library(dplyr) Ribba2012 &lt;- Ribba2012() ### Convert to classic rxode2 model with ini attached r &lt;- Ribba2012$simulationIniModel pars &lt;- rxInits(r) pars &lt;- pars[regexpr(&quot;(prop|eta)&quot;,names(pars)) == -1] print(pars) #&gt; k tkde tkpq tkqpp tlambdap tgamma #&gt; 1.00e+02 2.40e-01 2.95e-02 3.10e-03 1.21e-01 7.29e-01 #&gt; tdeltaqp tpt0 tq0 rxerr.pstar #&gt; 8.67e-03 7.13e+00 4.12e+01 1.00e+00 #### This is the exported method for simulation of Theta/Omega internally in rxode2 df &lt;- rxSimThetaOmega(params=pars, omega=omega,dfSub=760, thetaMat=thetaMat, thetaLower=0, nSub=60,nStud=60) %&gt;% filter(tkde &gt; tlambdap) %&gt;% as_tibble() #### You could also simulate more and bind them together to a data frame. print(df) #&gt; # A tibble: 2,280 x 17 #&gt; k tkde tkpq tkqpp tlambdap tgamma tdeltaqp tpt0 tq0 rxerr.pstar #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 100 2.98 0.0295 1.09 1.83 1.19 1.61 7.40 41.8 1 #&gt; 2 100 2.98 0.0295 1.09 1.83 1.19 1.61 7.40 41.8 1 #&gt; 3 100 2.98 0.0295 1.09 1.83 1.19 1.61 7.40 41.8 1 #&gt; 4 100 2.98 0.0295 1.09 1.83 1.19 1.61 7.40 41.8 1 #&gt; 5 100 2.98 0.0295 1.09 1.83 1.19 1.61 7.40 41.8 1 #&gt; 6 100 2.98 0.0295 1.09 1.83 1.19 1.61 7.40 41.8 1 #&gt; 7 100 2.98 0.0295 1.09 1.83 1.19 1.61 7.40 41.8 1 #&gt; 8 100 2.98 0.0295 1.09 1.83 1.19 1.61 7.40 41.8 1 #&gt; 9 100 2.98 0.0295 1.09 1.83 1.19 1.61 7.40 41.8 1 #&gt; 10 100 2.98 0.0295 1.09 1.83 1.19 1.61 7.40 41.8 1 #&gt; # i 2,270 more rows #&gt; # i 7 more variables: eta.pt0 &lt;dbl&gt;, eta.q0 &lt;dbl&gt;, eta.lambdap &lt;dbl&gt;, #&gt; # eta.kqp &lt;dbl&gt;, eta.kqpp &lt;dbl&gt;, eta.deltaqp &lt;dbl&gt;, eta.tkde &lt;dbl&gt; #### Quick check to make sure that all the parameters are OK. all(df$tkde&gt;df$tlambdap) #&gt; [1] TRUE sim1 &lt;- r %&gt;% # Use rxode2 et(time.units=&quot;months&quot;) %&gt;% # Pipe to a new event table et(amt=1, time=50, until=58, ii=1.5) %&gt;% # Add dosing every 1.5 months et(0, 250, by=0.5) %&gt;% # Add some sampling times (not required) rxSolve(df) #### Note this information looses information about which ID is in a #### &quot;study&quot;, so it summarizes the confidence intervals by dividing the #### subjects into sqrt(#subjects) subjects and then summarizes the #### confidence intervals sim2 &lt;- sim1 %&gt;% confint(c(&quot;pt&quot;,&quot;q&quot;,&quot;qp&quot;,&quot;sim&quot;),level=0.90); # Create Simulation intervals save(sim2, file = file.path(system.file(package = &quot;rxode2&quot;), &quot;pipeline-sim2.rds&quot;), version = 2) sim2 %&gt;% plot() 13.4 Speeding up rxode2 13.4.1 A note about the speed of the functional form for rxode2 The functional form has the benefit that it is what is supported by nlmixr2 and therefore there is only one interface between solving and estimating, and it takes some computation time to get to the underlying “classic” simulation code. These models are in the form of: library(rxode2) mod1 &lt;- function() { ini({ KA &lt;- 0.3 CL &lt;- 7 V2 &lt;- 40 Q &lt;- 10 V3 &lt;- 300 Kin &lt;- 0.2 Kout &lt;- 0.2 EC50 &lt;- 8 }) model({ C2 = centr/V2 C3 = peri/V3 d/dt(depot) = -KA*depot d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3 d/dt(peri) = Q*C2 - Q*C3 d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff eff(0) = 1 }) } Or you can also specify the end-points for simulation/estimation just like nlmixr2: mod2 &lt;- function() { ini({ TKA &lt;- 0.3 TCL &lt;- 7 TV2 &lt;- 40 TQ &lt;- 10 TV3 &lt;- 300 TKin &lt;- 0.2 TKout &lt;- 0.2 TEC50 &lt;- 8 eta.cl + eta.v ~ c(0.09, 0.08, 0.25) c2.prop.sd &lt;- 0.1 eff.add.sd &lt;- 0.1 }) model({ KA &lt;- TKA CL &lt;- TCL*exp(eta.cl) V2 &lt;- TV2*exp(eta.v) Q &lt;- TQ V3 &lt;- TV3 Kin &lt;- TKin Kout &lt;- TKout EC50 &lt;- TEC50 C2 = centr/V2 C3 = peri/V3 d/dt(depot) = -KA*depot d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3 d/dt(peri) = Q*C2 - Q*C3 d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff eff(0) = 1 C2 ~ prop(c2.prop.sd) eff ~ add(eff.add.sd) }) } For every solve, there is a compile (or a cached compile) of the underlying model. If you wish to speed this process up you can use the two underlying rxode2 classic models. This takes two steps: Parsing/evaluating the model Creating the simulation model The first step can be done by rxode2(mod1) or mod1() (or for the second model too). mod1 &lt;- mod1() mod2 &lt;- rxode2(mod2) The second step is to create the underlying “classic” rxode2 model, which can be done with two different methods:$simulationModel and $simulationIniModel. The $simulationModel will provide the simulation code without the initial conditions pre-pended, the $simulationIniModel will pre-pend the values. When the endpoints are specified, the simulation code for each endpoint is also output. You can see the differences below: summary(mod1$simulationModel) #&gt; rxode2 2.0.13.9000 model named rx_a494135736b19051a1ab9bccf8fb694c model (ready). #&gt; DLL: /tmp/RtmpbXPxP7/rxode2/rx_a494135736b19051a1ab9bccf8fb694c__.rxd/rx_a494135736b19051a1ab9bccf8fb694c_.so #&gt; NULL #&gt; #&gt; Calculated Variables: #&gt; [1] &quot;C2&quot; &quot;C3&quot; #&gt; -- rxode2 Model Syntax -- #&gt; rxode2({ #&gt; param(KA, CL, V2, Q, V3, Kin, Kout, EC50) #&gt; C2 = centr/V2 #&gt; C3 = peri/V3 #&gt; d/dt(depot) = -KA * depot #&gt; d/dt(centr) = KA * depot - CL * C2 - Q * C2 + Q * C3 #&gt; d/dt(peri) = Q * C2 - Q * C3 #&gt; d/dt(eff) = Kin - Kout * (1 - C2/(EC50 + C2)) * eff #&gt; eff(0) = 1 #&gt; }) summary(mod1$simulationIniModel) #&gt; rxode2 2.0.13.9000 model named rx_e8a4518d378b3595346005616a2c2d3f model (ready). #&gt; DLL: /tmp/RtmpbXPxP7/rxode2/rx_e8a4518d378b3595346005616a2c2d3f__.rxd/rx_e8a4518d378b3595346005616a2c2d3f_.so #&gt; NULL #&gt; #&gt; Calculated Variables: #&gt; [1] &quot;C2&quot; &quot;C3&quot; #&gt; -- rxode2 Model Syntax -- #&gt; rxode2({ #&gt; param(KA, CL, V2, Q, V3, Kin, Kout, EC50) #&gt; KA = 0.3 #&gt; CL = 7 #&gt; V2 = 40 #&gt; Q = 10 #&gt; V3 = 300 #&gt; Kin = 0.2 #&gt; Kout = 0.2 #&gt; EC50 = 8 #&gt; C2 = centr/V2 #&gt; C3 = peri/V3 #&gt; d/dt(depot) = -KA * depot #&gt; d/dt(centr) = KA * depot - CL * C2 - Q * C2 + Q * C3 #&gt; d/dt(peri) = Q * C2 - Q * C3 #&gt; d/dt(eff) = Kin - Kout * (1 - C2/(EC50 + C2)) * eff #&gt; eff(0) = 1 #&gt; }) summary(mod2$simulationModel) #&gt; rxode2 2.0.13.9000 model named rx_8c827ffb58fffede046fd8aa03787f1f model (ready). #&gt; DLL: /tmp/RtmpbXPxP7/rxode2/rx_8c827ffb58fffede046fd8aa03787f1f__.rxd/rx_8c827ffb58fffede046fd8aa03787f1f_.so #&gt; NULL #&gt; #&gt; Calculated Variables: #&gt; [1] &quot;KA&quot; &quot;CL&quot; &quot;V2&quot; &quot;Q&quot; &quot;V3&quot; &quot;Kin&quot; #&gt; [7] &quot;Kout&quot; &quot;EC50&quot; &quot;C2&quot; &quot;C3&quot; &quot;ipredSim&quot; &quot;sim&quot; #&gt; -- rxode2 Model Syntax -- #&gt; rxode2({ #&gt; param(TKA, TCL, TV2, TQ, TV3, TKin, TKout, TEC50, c2.prop.sd, #&gt; eff.add.sd, eta.cl, eta.v) #&gt; KA = TKA #&gt; CL = TCL * exp(eta.cl) #&gt; V2 = TV2 * exp(eta.v) #&gt; Q = TQ #&gt; V3 = TV3 #&gt; Kin = TKin #&gt; Kout = TKout #&gt; EC50 = TEC50 #&gt; C2 = centr/V2 #&gt; C3 = peri/V3 #&gt; d/dt(depot) = -KA * depot #&gt; d/dt(centr) = KA * depot - CL * C2 - Q * C2 + Q * C3 #&gt; d/dt(peri) = Q * C2 - Q * C3 #&gt; d/dt(eff) = Kin - Kout * (1 - C2/(EC50 + C2)) * eff #&gt; eff(0) = 1 #&gt; if (CMT == 5) { #&gt; rx_yj_ ~ 2 #&gt; rx_lambda_ ~ 1 #&gt; rx_low_ ~ 0 #&gt; rx_hi_ ~ 1 #&gt; rx_pred_f_ ~ C2 #&gt; rx_pred_ ~ rx_pred_f_ #&gt; rx_r_ ~ (rx_pred_f_ * c2.prop.sd)^2 #&gt; ipredSim = rxTBSi(rx_pred_, rx_lambda_, rx_yj_, rx_low_, #&gt; rx_hi_) #&gt; sim = rxTBSi(rx_pred_ + sqrt(rx_r_) * rxerr.C2, rx_lambda_, #&gt; rx_yj_, rx_low_, rx_hi_) #&gt; } #&gt; if (CMT == 4) { #&gt; rx_yj_ ~ 2 #&gt; rx_lambda_ ~ 1 #&gt; rx_low_ ~ 0 #&gt; rx_hi_ ~ 1 #&gt; rx_pred_f_ ~ eff #&gt; rx_pred_ ~ rx_pred_f_ #&gt; rx_r_ ~ (eff.add.sd)^2 #&gt; ipredSim = rxTBSi(rx_pred_, rx_lambda_, rx_yj_, rx_low_, #&gt; rx_hi_) #&gt; sim = rxTBSi(rx_pred_ + sqrt(rx_r_) * rxerr.eff, rx_lambda_, #&gt; rx_yj_, rx_low_, rx_hi_) #&gt; } #&gt; cmt(C2) #&gt; dvid(5, 4) #&gt; }) summary(mod2$simulationIniModel) #&gt; rxode2 2.0.13.9000 model named rx_b94547270f4dde0be08e575b3aa805d6 model (ready). #&gt; DLL: /tmp/RtmpbXPxP7/rxode2/rx_b94547270f4dde0be08e575b3aa805d6__.rxd/rx_b94547270f4dde0be08e575b3aa805d6_.so #&gt; NULL #&gt; #&gt; Calculated Variables: #&gt; [1] &quot;KA&quot; &quot;CL&quot; &quot;V2&quot; &quot;Q&quot; &quot;V3&quot; &quot;Kin&quot; #&gt; [7] &quot;Kout&quot; &quot;EC50&quot; &quot;C2&quot; &quot;C3&quot; &quot;ipredSim&quot; &quot;sim&quot; #&gt; -- rxode2 Model Syntax -- #&gt; rxode2({ #&gt; param(TKA, TCL, TV2, TQ, TV3, TKin, TKout, TEC50, c2.prop.sd, #&gt; eff.add.sd, eta.cl, eta.v) #&gt; rxerr.C2 = 1 #&gt; rxerr.eff = 1 #&gt; TKA = 0.3 #&gt; TCL = 7 #&gt; TV2 = 40 #&gt; TQ = 10 #&gt; TV3 = 300 #&gt; TKin = 0.2 #&gt; TKout = 0.2 #&gt; TEC50 = 8 #&gt; c2.prop.sd = 0.1 #&gt; eff.add.sd = 0.1 #&gt; eta.cl = 0 #&gt; eta.v = 0 #&gt; KA = TKA #&gt; CL = TCL * exp(eta.cl) #&gt; V2 = TV2 * exp(eta.v) #&gt; Q = TQ #&gt; V3 = TV3 #&gt; Kin = TKin #&gt; Kout = TKout #&gt; EC50 = TEC50 #&gt; C2 = centr/V2 #&gt; C3 = peri/V3 #&gt; d/dt(depot) = -KA * depot #&gt; d/dt(centr) = KA * depot - CL * C2 - Q * C2 + Q * C3 #&gt; d/dt(peri) = Q * C2 - Q * C3 #&gt; d/dt(eff) = Kin - Kout * (1 - C2/(EC50 + C2)) * eff #&gt; eff(0) = 1 #&gt; if (CMT == 5) { #&gt; rx_yj_ ~ 2 #&gt; rx_lambda_ ~ 1 #&gt; rx_low_ ~ 0 #&gt; rx_hi_ ~ 1 #&gt; rx_pred_f_ ~ C2 #&gt; rx_pred_ ~ rx_pred_f_ #&gt; rx_r_ ~ (rx_pred_f_ * c2.prop.sd)^2 #&gt; ipredSim = rxTBSi(rx_pred_, rx_lambda_, rx_yj_, rx_low_, #&gt; rx_hi_) #&gt; sim = rxTBSi(rx_pred_ + sqrt(rx_r_) * rxerr.C2, rx_lambda_, #&gt; rx_yj_, rx_low_, rx_hi_) #&gt; } #&gt; if (CMT == 4) { #&gt; rx_yj_ ~ 2 #&gt; rx_lambda_ ~ 1 #&gt; rx_low_ ~ 0 #&gt; rx_hi_ ~ 1 #&gt; rx_pred_f_ ~ eff #&gt; rx_pred_ ~ rx_pred_f_ #&gt; rx_r_ ~ (eff.add.sd)^2 #&gt; ipredSim = rxTBSi(rx_pred_, rx_lambda_, rx_yj_, rx_low_, #&gt; rx_hi_) #&gt; sim = rxTBSi(rx_pred_ + sqrt(rx_r_) * rxerr.eff, rx_lambda_, #&gt; rx_yj_, rx_low_, rx_hi_) #&gt; } #&gt; cmt(C2) #&gt; dvid(5, 4) #&gt; }) If you wish to speed up multiple simualtions from the rxode2 functions, you need to pre-calculate care of the steps above: mod1 &lt;- mod1$simulationModel mod2 &lt;- mod2$simulationModel These functions then can act like a normal ui model to be solved. You can convert them back to a UI as.rxUi() or a function as.function() as needed. To increase speed for multiple simulations from the same model you should use the lower level simulation model (ie $simulationModel or $simulationIniModel depending on what you need) 13.4.2 Increasing rxode2 speed by multi-subject parallel solving Using the classic rxode2 model specification (which we can convert from a functional/ui model style) we will continue the discussion on rxode2 speed enhancements. rxode2 originally developed as an ODE solver that allowed an ODE solve for a single subject. This flexibility is still supported. The original code from the rxode2 tutorial is below: library(rxode2) library(microbenchmark) library(ggplot2) mod1 &lt;- rxode2({ C2 = centr/V2 C3 = peri/V3 d/dt(depot) = -KA*depot d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3 d/dt(peri) = Q*C2 - Q*C3 d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff eff(0) = 1 }) #### Create an event table ev &lt;- et() %&gt;% et(amt=10000, addl=9,ii=12) %&gt;% et(time=120, amt=20000, addl=4, ii=24) %&gt;% et(0:240) ## Add Sampling nsub &lt;- 100 # 100 sub-problems sigma &lt;- matrix(c(0.09,0.08,0.08,0.25),2,2) # IIV covariance matrix mv &lt;- rxRmvn(n=nsub, rep(0,2), sigma) # Sample from covariance matrix CL &lt;- 7*exp(mv[,1]) V2 &lt;- 40*exp(mv[,2]) params.all &lt;- cbind(KA=0.3, CL=CL, V2=V2, Q=10, V3=300, Kin=0.2, Kout=0.2, EC50=8) 13.4.2.1 For Loop The slowest way to code this is to use a for loop. In this example we will enclose it in a function to compare timing. runFor &lt;- function(){ res &lt;- NULL for (i in 1:nsub) { params &lt;- params.all[i,] x &lt;- mod1$solve(params, ev) ##Store results for effect compartment res &lt;- cbind(res, x[, &quot;eff&quot;]) } return(res) } 13.4.2.2 Running with apply In general for R, the apply types of functions perform better than a for loop, so the tutorial also suggests this speed enhancement runSapply &lt;- function(){ res &lt;- apply(params.all, 1, function(theta) mod1$run(theta, ev)[, &quot;eff&quot;]) } 13.4.2.3 Run using a single-threaded solve You can also have rxode2 solve all the subject simultaneously without collecting the results in R, using a single threaded solve. The data output is slightly different here, but still gives the same information: runSingleThread &lt;- function(){ solve(mod1, params.all, ev, cores=1)[,c(&quot;sim.id&quot;, &quot;time&quot;, &quot;eff&quot;)] } 13.4.2.4 Run a 2 threaded solve rxode2 supports multi-threaded solves, so another option is to have 2 threads (called cores in the solve options, you can see the options in rxControl() or rxSolve()). run2Thread &lt;- function(){ solve(mod1, params.all, ev, cores=2)[,c(&quot;sim.id&quot;, &quot;time&quot;, &quot;eff&quot;)] } 13.4.2.5 Compare the times between all the methods Now the moment of truth, the timings: bench &lt;- microbenchmark(runFor(), runSapply(), runSingleThread(),run2Thread()) print(bench) #&gt; Unit: milliseconds #&gt; expr min lq mean median uq max #&gt; runFor() 226.80259 231.46430 238.46184 234.91714 238.62226 503.03838 #&gt; runSapply() 226.17992 231.61599 238.69159 234.84238 238.65584 517.06355 #&gt; runSingleThread() 21.73833 22.69128 23.18974 23.32014 23.60377 30.82214 #&gt; run2Thread() 12.69923 13.34349 13.84174 13.84864 14.01386 21.63286 #&gt; neval #&gt; 100 #&gt; 100 #&gt; 100 #&gt; 100 autoplot(bench) It is clear that the largest jump in performance when using the solve method and providing all the parameters to rxode2 to solve without looping over each subject with either a for or a sapply. The number of cores/threads applied to the solve also plays a role in the solving. We can explore the number of threads further with the following code: runThread &lt;- function(n){ solve(mod1, params.all, ev, cores=n)[,c(&quot;sim.id&quot;, &quot;time&quot;, &quot;eff&quot;)] } bench &lt;- eval(parse(text=sprintf(&quot;microbenchmark(%s)&quot;, paste(paste0(&quot;runThread(&quot;, seq(1, 2 * rxCores()),&quot;)&quot;), collapse=&quot;,&quot;)))) print(bench) #&gt; Unit: milliseconds #&gt; expr min lq mean median uq max neval #&gt; runThread(1) 21.156241 22.162005 28.92567 25.503911 32.63468 69.03869 100 #&gt; runThread(2) 12.582237 13.471725 18.33534 15.168085 21.69747 37.58077 100 #&gt; runThread(3) 9.738105 10.791214 15.40642 12.975344 17.76421 33.30203 100 #&gt; runThread(4) 8.329495 9.196881 12.33852 10.966012 14.64972 27.79702 100 #&gt; runThread(5) 7.434857 8.589648 12.36991 10.434525 14.53453 35.36355 100 #&gt; runThread(6) 7.155785 7.900791 10.69021 8.976488 12.27102 31.42603 100 #&gt; runThread(7) 6.893432 8.657700 14.01415 10.800231 18.38594 32.74863 100 #&gt; runThread(8) 6.765653 8.333562 14.74611 11.299252 18.17180 34.42415 100 #&gt; runThread(9) 8.286625 10.074962 18.22466 13.118453 22.58021 38.33926 100 #&gt; runThread(10) 8.481860 10.582388 19.62018 14.270838 32.36746 38.22258 100 #&gt; runThread(11) 8.155198 9.691569 17.18156 13.570675 21.14222 36.02348 100 #&gt; runThread(12) 8.337740 9.921684 18.18838 13.135094 31.72638 46.74915 100 #&gt; runThread(13) 7.974870 9.908901 18.31133 13.696796 28.37834 34.74034 100 #&gt; runThread(14) 7.961936 9.586060 18.70272 12.792196 32.21532 39.28540 100 #&gt; runThread(15) 7.636325 9.044776 16.15580 11.223229 19.90421 40.54116 100 #&gt; runThread(16) 7.732445 9.995808 19.08606 18.113271 31.22584 36.88623 100 autoplot(bench) There can be a suite spot in speed vs number or cores. The system type (mac, linux, windows and/or processor), complexity of the ODE solving and the number of subjects may affect this arbitrary number of threads. 4 threads is a good number to use without any prior knowledge because most systems these days have at least 4 threads (or 2 processors with 4 threads). 13.4.3 A real life example Before some of the parallel solving was implemented, the fastest way to run rxode2 was with lapply. This is how Rik Schoemaker created the data-set for nlmixr comparisons, but reduced to run faster automatic building of the pkgdown website. library(rxode2) library(data.table) #Define the rxode2 model ode1 &lt;- &quot; d/dt(abs) = -KA*abs; d/dt(centr) = KA*abs-(CL/V)*centr; C2=centr/V; &quot; #Create the rxode2 simulation object mod1 &lt;- rxode2(model = ode1) #Population parameter values on log-scale paramsl &lt;- c(CL = log(4), V = log(70), KA = log(1)) #make 10,000 subjects to sample from: nsubg &lt;- 300 # subjects per dose doses &lt;- c(10, 30, 60, 120) nsub &lt;- nsubg * length(doses) #IIV of 30% for each parameter omega &lt;- diag(c(0.09, 0.09, 0.09))# IIV covariance matrix sigma &lt;- 0.2 #Sample from the multivariate normal set.seed(98176247) rxSetSeed(98176247) library(MASS) mv &lt;- mvrnorm(nsub, rep(0, dim(omega)[1]), omega) # Sample from covariance matrix #Combine population parameters with IIV params.all &lt;- data.table( &quot;ID&quot; = seq(1:nsub), &quot;CL&quot; = exp(paramsl[&#39;CL&#39;] + mv[, 1]), &quot;V&quot; = exp(paramsl[&#39;V&#39;] + mv[, 2]), &quot;KA&quot; = exp(paramsl[&#39;KA&#39;] + mv[, 3]) ) #set the doses (looping through the 4 doses) params.all[, AMT := rep(100 * doses,nsubg)] Startlapply &lt;- Sys.time() #Run the simulations using lapply for speed s = lapply(1:nsub, function(i) { #selects the parameters associated with the subject to be simulated params &lt;- params.all[i] #creates an eventTable with 7 doses every 24 hours ev &lt;- eventTable() ev$add.dosing( dose = params$AMT, nbr.doses = 1, dosing.to = 1, rate = NULL, start.time = 0 ) #generates 4 random samples in a 24 hour period ev$add.sampling(c(0, sort(round(sample(runif(600, 0, 1440), 4) / 60, 2)))) #runs the rxode2 simulation x &lt;- as.data.table(mod1$run(params, ev)) #merges the parameters and ID number to the simulation output x[, names(params) := params] }) #runs the entire sequence of 100 subjects and binds the results to the object res res = as.data.table(do.call(&quot;rbind&quot;, s)) Stoplapply &lt;- Sys.time() print(Stoplapply - Startlapply) #&gt; Time difference of 14.49963 secs By applying some of the new parallel solving concepts you can simply run the same simulation both with less code and faster: rx &lt;- rxode2({ CL = log(4) V = log(70) KA = log(1) CL = exp(CL + eta.CL) V = exp(V + eta.V) KA = exp(KA + eta.KA) d/dt(abs) = -KA*abs; d/dt(centr) = KA*abs-(CL/V)*centr; C2=centr/V; }) omega &lt;- lotri(eta.CL ~ 0.09, eta.V ~ 0.09, eta.KA ~ 0.09) doses &lt;- c(10, 30, 60, 120) startParallel &lt;- Sys.time() ev &lt;- do.call(&quot;rbind&quot;, lapply(seq_along(doses), function(i){ et() %&gt;% et(amt=doses[i]) %&gt;% # Add single dose et(0) %&gt;% # Add 0 observation #### Generate 4 samples in 24 hour period et(lapply(1:4, function(...){c(0, 24)})) %&gt;% et(id=seq(1, nsubg) + (i - 1) * nsubg) %&gt;% #### Convert to data frame to skip sorting the data #### When binding the data together as.data.frame })) #### To better compare, use the same output, that is data.table res &lt;- rxSolve(rx, ev, omega=omega, returnType=&quot;data.table&quot;) endParallel &lt;- Sys.time() print(endParallel - startParallel) #&gt; Time difference of 0.1268315 secs You can see a striking time difference between the two methods; A few things to keep in mind: rxode2 use the thread-safe sitmo threefry routines for simulation of eta values. Therefore the results are expected to be different (also the random samples are taken in a different order which would be different) This prior simulation was run in R 3.5, which has a different random number generator so the results in this simulation will be different from the actual nlmixr comparison when using the slower simulation. This speed comparison used data.table. rxode2 uses data.table internally (when available) try to speed up sorting, so this would be different than installations where data.table is not installed. You can force rxode2 to use order() when sorting by using forderForceBase(TRUE). In this case there is little difference between the two, though in other examples data.table’s presence leads to a speed increase (and less likely it could lead to a slowdown). 13.4.3.1 Want more ways to run multi-subject simulations The version since the tutorial has even more ways to run multi-subject simulations, including adding variability in sampling and dosing times with et() (see rxode2 events for more information), ability to supply both an omega and sigma matrix as well as adding as a thetaMat to R to simulate with uncertainty in the omega, sigma and theta matrices; see rxode2 simulation vignette. 13.5 Integrating rxode2 models in your package 13.5.1 Using Pre-compiled models in your packages If you have a package and would like to include pre-compiled rxode2 models in your package it is easy to create the package. You simple make the package with the rxPkg() command. library(rxode2); #### Now Create a model idr &lt;- rxode2({ C2 = centr/V2; C3 = peri/V3; d/dt(depot) =-KA*depot; d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; }) #### You can specify as many models as you want to add rxPkg(idr, package=&quot;myPackage&quot;); ## Add the idr model to your package This will: Add the model to your package; You can use the package data as idr once the package loads Add the right package requirements to the DESCRIPTION file. You will want to update this to describe the package and modify authors, license etc. Create skeleton model documentation files you can add to for your package documentation. In this case it would be the file idr-doc.R in your R directory Create a configure and configure.win script that removes and regenerates the src directory based on whatever version of rxode2 this is compiled against. This should be modified if you plan to have your own compiled code, though this is not suggested. You can write your own R code in your package that interacts with the rxode2 object so you can distribute shiny apps and similar things in the package context. Once this is present you can add more models to your package by rxUse(). Simply compile the rxode2 model in your package then add the model with rxUse() rxUse(model) Now both model and idr are in the model library. This will also create model-doc.R in your R directory so you can document this model. You can then use devtools methods to install/test your model devtools::load_all() # Load all the functions in the package devtools::document() # Create package documentation devtools::install() # Install package devtools::check() # Check the package devtools::build() # build the package so you can submit it to places like CRAN 13.5.2 Using Models in a already present package To illustrate, lets start with a blank package library(rxode2) library(usethis) pkgPath &lt;- file.path(rxTempDir(),&quot;MyRxModel&quot;) create_package(pkgPath); use_gpl3_license(&quot;Matt&quot;) use_package(&quot;rxode2&quot;, &quot;LinkingTo&quot;) use_package(&quot;rxode2&quot;, &quot;Depends&quot;) ## library(rxode2) on load; Can use imports instead. use_roxygen_md() ##use_readme_md() library(rxode2); #### Now Create a model idr &lt;- rxode2({ C2 = centr/V2; C3 = peri/V3; d/dt(depot) =-KA*depot; d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; }); rxUse(idr); ## Add the idr model to your package rxUse(); # Update the compiled rxode2 sources for all of your packages The rxUse() will: - Create rxode2 sources and move them into the package’s src/ directory. If there is only R source in the package, it will also finish off the directory with an library-init.c which registers all the rxode2 models in the package for use in R. - Create stub R documentation for each of the models your are including in your package. You will be able to see the R documentation when loading your package by the standard ? interface. You will still need to: - Export at least one function. If you do not have a function that you wish to export, you can add a re-export of rxode2 using roxygen as follows: ##&#39; @importFrom rxode2 rxode2 ##&#39; @export rxode2::rxode2 If you want to use Suggests instead of Depends in your package, you way want to export all of rxode2’s normal routines ##&#39; @importFrom rxode2 rxode2 ##&#39; @export rxode2::rxode2 ##&#39; @importFrom rxode2 et ##&#39; @export rxode2::et ##&#39; @importFrom rxode2 etRep ##&#39; @export rxode2::etRep ##&#39; @importFrom rxode2 etSeq ##&#39; @export rxode2::etSeq ##&#39; @importFrom rxode2 as.et ##&#39; @export rxode2::as.et ##&#39; @importFrom rxode2 eventTable ##&#39; @export rxode2::eventTable ##&#39; @importFrom rxode2 add.dosing ##&#39; @export rxode2::add.dosing ##&#39; @importFrom rxode2 add.sampling ##&#39; @export rxode2::add.sampling ##&#39; @importFrom rxode2 rxSolve ##&#39; @export rxode2::rxSolve ##&#39; @importFrom rxode2 rxControl ##&#39; @export rxode2::rxControl ##&#39; @importFrom rxode2 rxClean ##&#39; @export rxode2::rxClean ##&#39; @importFrom rxode2 rxUse ##&#39; @export rxode2::rxUse ##&#39; @importFrom rxode2 rxShiny ##&#39; @export rxode2::rxShiny ##&#39; @importFrom rxode2 genShinyApp.template ##&#39; @export rxode2::genShinyApp.template ##&#39; @importFrom rxode2 cvPost ##&#39; @export rxode2::cvPost ### This is actually from `magrittr` but allows less imports ##&#39; @importFrom rxode2 %&gt;% ##&#39; @export rxode2::`%&gt;%` You also need to instruct R to load the model library models included in the model’s dll. This is done by: ### In this case `rxModels` is the package name ##&#39; @useDynLib rxModels, .registration=TRUE If this is a R package with rxode2 models and you do not intend to add any other compiled sources (recommended), you can add the following configure scripts #!/bin/sh ### This should be used for both configure and configure.win echo &quot;unlink(&#39;src&#39;, recursive=TRUE);rxode2::rxUse()&quot; &gt; build.R ${R_HOME}/bin/Rscript build.R rm build.R Depending on the check you may need a dummy autoconf script, #### dummy autoconf script #### It is saved to configure.ac If you want to integrate with other sources in your Rcpp or C/Fortan based packages, you need to include rxModels-compiled.h and: - Add the define macro compiledModelCall to the list of registered .Call functions. - Register C interface to allow model solving by R_init0_rxModels_rxode2_models() (again rxModels would be replaced by your package name). Once this is complete, you can compile/document by the standard methods: devtools::load_all() devtools::document() devtools::install() If you load the package with a new version of rxode2, the models will be recompiled when they are used. However, if you want the models recompiled for the most recent version of rxode2, you simply need to call rxUse() again in the project directory followed by the standard methods for install/create a package. devtools::load_all() devtools::document() devtools::install() Note you do not have to include the rxode2 code required to generate the model to regenerate the rxode2 c-code in the src directory. As with all rxode2 objects, a summary will show one way to recreate the same model. An example of compiled models package can be found in the rxModels repository. 13.6 Stiff ODEs with Jacobian Specification 13.6.0.1 Stiff ODEs with Jacobian Specification Occasionally, you may come across a stiff differential equation, that is a differential equation that is numerically unstable and small variations in parameters cause different solutions to the ODEs. One way to tackle this is to choose a stiff-solver, or hybrid stiff solver (like the default LSODA). Typically this is enough. However exact Jacobian solutions may increase the stability of the ODE. (Note the Jacobian is the derivative of the ODE specification with respect to each variable). In rxode2 you can specify the Jacobian with the df(state)/dy(variable)= statement. A classic ODE that has stiff properties under various conditions is the Van der Pol differential equations. In rxode2 these can be specified by the following: library(rxode2) Vtpol2 &lt;- function() { ini({ mu &lt;- 1 ## nonstiff; 10 moderately stiff; 1000 stiff }) model({ d/dt(y) &lt;- dy d/dt(dy) &lt;- mu*(1-y^2)*dy - y ##### Jacobian df(y)/dy(dy) &lt;- 1 df(dy)/dy(y) &lt;- -2*dy*mu*y - 1 df(dy)/dy(dy) &lt;- mu*(1-y^2) ##### Initial conditions y(0) &lt;- 2 dy(0) &lt;- 0 }) } et &lt;- et(0, 10, length.out=200) %&gt;% et(amt=0) s1 &lt;- Vtpol2 %&gt;% solve(et, method=&quot;lsoda&quot;) print(s1) #&gt; -- Solved rxode2 object -- #&gt; -- Parameters ($params): -- #&gt; mu #&gt; 1 #&gt; -- Initial Conditions ($inits): -- #&gt; y dy #&gt; 2 0 #&gt; -- First part of data (object): -- #&gt; # A tibble: 200 x 3 #&gt; time y dy #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 2 0 #&gt; 2 0.0503 2.00 -0.0933 #&gt; 3 0.101 1.99 -0.173 #&gt; 4 0.151 1.98 -0.242 #&gt; 5 0.201 1.97 -0.302 #&gt; 6 0.251 1.95 -0.353 #&gt; # i 194 more rows While this is not stiff at mu=1, mu=1000 is a stiff system s2 &lt;- Vtpol2 %&gt;% solve(c(mu=1000), et) print(s2) #&gt; -- Solved rxode2 object -- #&gt; -- Parameters ($params): -- #&gt; mu #&gt; 1000 #&gt; -- Initial Conditions ($inits): -- #&gt; y dy #&gt; 2 0 #&gt; -- First part of data (object): -- #&gt; # A tibble: 200 x 3 #&gt; time y dy #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 2 0 #&gt; 2 0.0503 2.00 -0.000667 #&gt; 3 0.101 2.00 -0.000667 #&gt; 4 0.151 2.00 -0.000667 #&gt; 5 0.201 2.00 -0.000667 #&gt; 6 0.251 2.00 -0.000667 #&gt; # i 194 more rows While this is easy enough to do, it is a bit tedious. If you have rxode2 setup appropriately, you can use the computer algebra system sympy to calculate the Jacobian automatically. This is done by the rxode2 option calcJac option: Vtpol &lt;- function() { ini({ mu &lt;- 1 ## nonstiff; 10 moderately stiff; 1000 stiff }) model({ d/dt(y) &lt;- dy d/dt(dy) &lt;- mu*(1-y^2)*dy - y y(0) &lt;- 2 dy(0) &lt;- 0 }) } Vtpol &lt;- Vtpol() #### you can also use $symengineModelPrune if there is if/else blocks #### that need to be converted: Vtpol &lt;- rxode2(Vtpol$symengineModelNoPrune, calcJac=TRUE) #&gt; [====|====|====|====|====|====|====|====|====|====] 0:00:00 summary(Vtpol) #&gt; rxode2 2.0.13.9000 model named rx_63a2e70a0dc6f6824bd7f0cc2c712813 model (ready). #&gt; DLL: /tmp/RtmpbXPxP7/rxode2/rx_63a2e70a0dc6f6824bd7f0cc2c712813__.rxd/rx_63a2e70a0dc6f6824bd7f0cc2c712813_.so #&gt; NULL #&gt; -- rxode2 Model Syntax -- #&gt; rxode2({ #&gt; cmt(y) #&gt; cmt(dy) #&gt; d/dt(y) = dy #&gt; d/dt(dy) = -y + mu * dy * (1 - Rx_pow_di(y, 2)) #&gt; y(0) = 2 #&gt; dy(0) = 0 #&gt; df(y)/dy(y) = 0 #&gt; df(dy)/dy(y) = -1 - 2 * y * mu * dy #&gt; df(y)/dy(dy) = 1 #&gt; df(dy)/dy(dy) = mu * (1 - Rx_pow_di(y, 2)) #&gt; df(y)/dy(mu) = 0 #&gt; df(dy)/dy(mu) = dy * (1 - Rx_pow_di(y, 2)) #&gt; }) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
